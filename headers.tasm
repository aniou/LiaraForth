; Dictionary Headers for Liara Forth for the W65C265SXB
; Scot W. Stevenson <scot.stevenson@gmail.com>
; First version: 05. Dec 2016
; This version: 06. Feb 2017

; Dictionary headers are kept separately from the code, which allows various
; tricks in the code. We roughly follow the Gforth terminology: The Execution
; Token (xt) is the address of the first byte of a word's code that can be,
; well, executed; the Name Token (nt) is a pointer to the beginning of the
; word's header in the Dictionary. There, the link to the next word in the
; Dictionary is always one cell down from the current word's own nt. In the code
; itself, we use "h_<WORD>" ("header") for the nt and "a_<WORD>" ("A" as the
; beginning) for the xt. 
;
; This gives us the following header structure for each header:

;              8 bit     8 bit
;               LSB       MSB
; h_word ->  +--------+--------+
;            | Length | Status |
;         +2 +--------+--------+
;            | Next Header     | -> h_next (nt of next word) 
;         +4 +-----------------+
;            | Start of Code   | -> a_word (xt of this word)
;         +6 +-----------------+
;            | End of Code     | -> z_word
;         +8 +--------+--------+
;            | Name   |        |
;            +--------+--------+
;            |        |        |
;            +--------+--------+
;            |        |  ...   | (name string does not end with a zero)
;         +n +--------+--------+

; Status bytes are created by adding dictionary flags defined in
; definitions.tasm:
;
;       PW - Primitive Word (natively coded)
;       CO - Compile Only
;       IM - Immediate Word
;       NC - Native Compile (inline compile)

; The last word (top word in code) is always BYE, signaled to FIND by a 0000 in
; the link to the Next Word field. The words are sorted with the more common
; ones first (further down in code) and the output words later (further up)
; because things will always be slow if there is a human involved.

h_bye   .byte 03    ; length of word string
        .byte { PW + NC } ; status byte
        .word 0000  ; next word in dictionary, 0000 signals end
        .word a_bye ; start of code, the xt of this word
        .word z_bye ; end of code (points to RTS)
        .byte "bye" ; lowercase word name

h_cold  .byte 4, 00
        .word h_bye, a_cold, z_cold
        .byte "cold"  

h_words .byte 5, { PW + NC }
        .word h_cold, a_words, z_words
        .byte "words"

h_bell  .byte 4, { PW + NC }
        .word h_words, a_bell, z_bell
        .byte "bell"

h_page  .byte 4, { PW + NC }
        .word h_bell, a_page, z_page
        .byte "page"

h_count .byte 5, {NC + PW }
        .word h_page, a_count, z_count
        .byte "count"

h_abort .byte 5, 00 ; TODO check flags
        .word h_count, a_abort, z_abort
        .byte "abort"

h_parse .byte 5, 00
        .word h_abort, a_parse, z_parse
        .byte "parse"

h_quit  .byte 4, 00
        .word h_parse, a_quit, z_quit
        .byte "quit"

h_name>int .byte 8, { PW + NC }
        .word h_quit, a_name>int, z_name>int
        .byte "name>int"

h_cr    .byte 2, { PW + NC }
        .word h_name>int, a_cr, z_cr 
        .byte "cr"

h_bl    .byte 2, { PW + NC }
        .word h_cr, a_bl, z_bl
        .byte "bl"

h_spaces .byte 6, { PW + NC }
        .word h_bl, a_spaces, z_spaces
        .byte "spaces"

h_space .byte 5, { PW + NC }
        .word h_spaces, a_space, z_space
        .byte "space"

h_dots  .byte 2, { PW + NC }
        .word h_space, a_dots, z_dots
        .byte ".s"

h_type  .byte 4, 0
        .word h_dots, a_type, z_type
        .byte "type"

h_dot   .byte 1, { PW + NC }
        .word h_type, a_dot, z_dot
        .byte '.'

h_allot .byte 5, { PW + NC }
        .word h_dot, a_allot, z_allot
        .byte "allot"

h_name>string .byte 0b, { PW + NC }
        .word h_allot, a_name>string, z_name>string
        .byte "name>string"

h_2dup  .byte 4, { PW + NC }
        .word h_name>string, a_2dup, z_2dup
        .byte "2dup"

h_abs   .byte 3, { PW + NC }
        .word h_2dup, a_abs, z_abs
        .byte "abs"

h_state .byte 5, { PW + NC }
        .word h_abs, a_state, z_state
        .byte "state"

h_to-in .byte 3, { PW + NC }
        .word h_state, a_to-in, z_to-in
        .byte ">in"

h_source .byte 6, { PW + NC }
         .word h_to-in, a_source, z_source
         .byte "source"

h_depth .byte 5, { PW + NC }
        .word h_source, a_depth, z_depth
        .byte "depth"

h_minus .byte 1, { PW + NC }
        .word h_depth, a_minus, z_minus
        .byte '-'

h_plus  .byte 1, { PW + NC }
        .word h_minus, a_plus, z_plus
        .byte '+'

h_one-plus .byte 2, { PW + NC }
        .word h_plus, a_one-plus, z_one-plus
        .byte "1+"

h_false .byte 5, { PW + NC }
        .word h_one-plus, a_zero, z_zero
        .byte "false"

h_true  .byte 4, { PW + NC }
        .word h_false, a_true, z_true
        .byte "true"

h_two   .byte 1, { PW + NC }
        .word h_true, a_two, z_two
        .byte '2'

h_one   .byte 1, { PW + NC }
        .word h_two, a_one, z_one
        .byte '1'

h_zero  .byte 1, { PW + NC }
        .word h_one, a_zero, z_zero
        .byte '0'

h_find-name .byte 9, 0
        .word h_zero, a_find-name, z_find-name
        .byte "find-name"

h_refill .byte 6, { PW } ; TODO check flags
        .word h_find-name, a_refill, z_refill
        .byte "refill"

h_parse-name .byte &10, 0
        .word h_refill, a_parse-name, z_parse-name
        .byte "parse-name"

h_source-id .byte 9, { PW + NC }
        .word h_parse-name, a_source-id, z_source-id
        .byte "source-id"

h_comma .byte 1, { PW + NC }
        .word h_source-id, a_comma, z_comma
        .byte ','

h_accept .byte 6, 00 ; TODO check flags
        .word h_comma, a_accept, z_accept 
        .byte "accept"

h_tuck  .byte 4, { PW + NC }
        .word h_accept, a_tuck, z_tuck
        .byte "tuck"

h_nip   .byte 3, { PW + NC }
        .word h_tuck, a_nip, z_nip
        .byte "nip"

h_rot   .byte 3, { PW + NC }
        .word h_nip, a_rot, z_rot
        .byte "rot"

h_execute .byte 7, { PW + NC }
        .word h_rot, a_execute, z_execute
        .byte "execute"

h_here  .byte 4, { PW + NC }
        .word h_execute, a_here, z_here
        .byte "here"

h_swap  .byte 4, { PW + NC }
        .word h_here, a_swap, z_swap
        .byte "swap"

h_dup   .byte 3, { PW + NC }
        .word h_swap, a_dup, z_dup
        .byte "dup"

; DROP is always the first entry in dictionary
h_drop  .byte 4, { PW + NC }
        .word h_dup, a_drop, z_drop
        .byte "drop"

; END
