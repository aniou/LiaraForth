; Dictionary Headers for Liara Forth for the W65C265SXB
; Scot W. Stevenson <scot.stevenson@gmail.com>
; First version: 05. Dec 2016
; This version: 30. Dec 2016

; Dictionary headers are kept separately from the code. For each word, the
; structure is:

;               8bit     8bit
; h_word ->  +--------+--------+
;            | Status | Length |
;         +2 +--------+--------+
;            | Start of Code   | -> a_word
;         +4 +-----------------+
;            | End of Code     | -> z_word
;         +6 +-----------------+
;            | Next Header     | -> h_next_word
;         +8 +--------+--------+
;            | Name   |        |
;            +--------+--------+
;            |        |        |
;            +--------+--------+
;            |        |  ...   |
;         +n +--------+--------+

; Status bytes are created by adding dictionary flags defined in
; definitions.tasm:
;
;       PW - Primitive Word (natively coded)
;       CO - Compile Only
;       IM - Immediate Word
;       NC - Native Compile (inline compile)

; The last word (top word in code) is always BYE, signaled to FIND by a 0000 in
; the link to the Next Word field. The words are sorted with the more common
; ones first (further down in code) and the output words later (further up)
; because things will always be slow if there is a human involved.

h_bye   .byte { PW + NC } ; status byte
        .byte 03    ; length of word string
        .word a_bye ; start of code
        .word z_bye ; end of code (points to RTS)
        .word 0000  ; next word in dictionary, 0000 signals is end
        .byte "bye" ; lowercase word name

h_cold  .byte 00, 4  
        .word a_cold, z_cold, h_bye
        .byte "cold"  

h_count .byte { NC + PW }, 5
        .word a_count, z_count, h_cold
        .byte "count"

h_abort .byte 00 , 5 ; TODO check flags
        .word a_abort, z_abort, h_count
        .byte "abort"

h_quit  .byte 00, 4 
        .word a_quit, z_quit, h_abort
        .byte "quit"

h_cr    .byte { PW + NC }, 2
        .word a_cr, z_cr, h_quit
        .byte "cr"

h_state .byte { PW + NC }, 5
        .word a_state, z_state, h_quit
        .byte "state"

h_plus  .byte { PW + NC }, 1
        .word a_plus, z_plus, h_state
        .byte '+'

h_one-plus .byte { PW + NC }, 2
        .word a_one-plus, z_one-plus, h_plus
        .byte "1+"

h_false .byte { PW + NC }, 5
        .word a_zero, z_zero, h_one-plus
        .byte "false"

h_true  .byte { PW + NC }, 4
        .word a_true, z_true, h_false
        .byte "true"

h_one   .byte { PW + NC }, 3
        .word a_one, z_one, h_true
        .byte "one"

h_zero  .byte { PW + NC }, 4
        .word a_zero, z_zero, h_one
        .byte "zero"

h_refill .byte { PW }, 6 ; TODO check flags
        .word a_refill, z_refill, h_zero
        .byte "refill"

h_source-id .byte { PW + NC }, 9
        .word a_source-id, z_source-id, h_refill
        .byte "source-id"

h_comma .byte { PW + NC }, 1
        .word a_comma, z_comma, h_source-id
        .byte ","

h_accept .byte 00, 6 ; TODO check flags
        .word a_accept, z_accept, h_source-id
        .byte "accept"

h_tuck  .byte { PW + NC }, 4
        .word a_tuck, z_tuck, h_accept
        .byte "tuck"

h_nip   .byte { PW + NC }, 3
        .word a_nip, z_nip, h_zero
        .byte "nip"

h_here  .byte { PW + NC }, 4
        .word a_here, z_here, h_nip
        .byte "here"

h_swap  .byte { PW + NC }, 04
        .word a_swap, z_swap, h_here
        .byte "swap"

h_dup   .byte { PW + NC }, 03
        .word a_dup, z_dup, h_swap
        .byte "dup"

h_drop  .byte { PW + NC }, 04
        .word a_drop, z_drop, h_dup
        .byte "drop"

