; Liara Forth for the W65C265SXB
; Scot W. Stevenson <scot.stevenson@gmail.com>
; First version: 01. Apr 2016
; This version: 14. Feb 2017

; This code is written in Typist's Assembler Notation for the 65c02/65816
; See docs/MANUAL.md for more information

        .mpu 65816
;       .origin 8000    ; start of code to save to Flash memory
        .origin 6000    ; start of code to save to built-in RAM

; ===================================================================
; TOP INCLUDES

        .include definitions.tasm

; Hardware dependencies are isolated to a large degree in kernel files. Liara
; Forth ships with two such files: One for the crude65816 emulator, and one for
; the 265sxb board. Only use one.

;       .include kernel_emu.tasm        ; routines for crude65815 emulator
        .include kernel_265sxb.tasm     ; routines for the W65C265SXB


; ===================================================================
; DICTIONARY ROUTINES

; Word code routines are sorted alphabetically, except for the first three
; - COLD, ABORT, and QUIT - and a few others that flow into each other. The
; byte and cycle values are calculated without the RTS instruction.


; -------------------------------------------------------------------
; COLD ( -- ) X bytes / X Cycles
; Reboot the system
xt_cold  

                jmp reset_hardware      ; don't use JSR, jump back to start
start           
        .native
        .a16
        .xy16
                sei

                ; TODO switch to Single Task mode
                ; TODO set up Direct Page stuff
                ; TODO initiate User variables
                
                ; The name token (nt) of DROP is always the first one in the
                ; virgin Dictionary, so we start off the Dictionary Pointer (DP)
                ; there. Adding high-level words will change this before the
                ; user has a chance to call WORDS
                lda.# nt_drop
                sta.d dp
                
                ; The compiler pointer (CP) points to the first free cell 
                ; in RAM
                lda.# cp0
                sta.d cp

                ; Prepare input buffers
                lda.# ibuffer1  ; start with first input buffer
                sta.d cib

                stz.d piblen    ; previous input buffer is empty
                stz.d insrc     ; SOURCE-ID is zero
                stz.d state     ; STATE is zero (interpret)
                
                ; Clear Data Stack
                ldy.# 0000
                ldx.# dsp0

                ; Clean the screen, assumes vt100 terminal
                jsr xt_page
                
                ; Define high-level words via EVALUATE. At this point, whatever
                ; is in Y (TOS) is rubbish, so we don't have to push it to the 
                ; stack first
                dex
                dex
                dex
                dex
                lda.# hi-start  
                sta.dx 00                       ; Start address goes in NOS
                ldy.# { hi-end - hi-start }     ; length goes in TOS

                jsr xt_evaluate

                ; drop through to ABORT

; -------------------------------------------------------------------
; ABORT ( -- ) 8+ bytes / X cycles
; Reset the parameter (data) stack pointer and continue as QUIT 
; We can jump here via subroutine because we reset the stack pointer
; anyway. Flows into QUIT.
; TODO see which parts of COLD we should integrate here
xt_abort         
        .a16    
                ; clear Data Stack
                ldy.# 0000
                ldx.# dsp0


; drops through to QUIT, z_abort is the same as z_quit.

; -------------------------------------------------------------------
; QUIT ( -- ) X bytes / X cycles
; Reset the input, clearning Return Stack. Jumps to QUIT do not have to be
; subroutine jumps as the Return Stack is cleared anyway. Liara Forth follows
; the ANSI Forth recommendation to use REFILL. Note we don't display the "ok"
; system prompt until after the first output. This follows Gforth.
xt_quit          
                ; clear Return Stack
                lda.# stack0
                tcs

                ; make sure Instruction Pointer is empty
                ; TODO move this someplace else or else it will end up in ROM
                stz execute_ip

                ; switch SOURCE-ID to zero (keyboard input)
                stz.d insrc
                
                ; switch to interpret state (STATE is zero)
                stz.d state
               
quit_get_line
                ; Empty current input buffer. Note the previous input line is
                ; conserved even if we came here from an abort
                stz.d ciblen
               
                ; Accept a line from the current input source
                jsr xt_refill            ; ( -- f ) 
                
                tya                     ; force flag test
                bne quit_refill_successful

                ; If REFILL returned a FALSE flag, something went wrong and we
                ; need to print an error message and reset the machine. We don't
                ; need to save TOS because we're going to clobber it anyway when we
                ; go back to ABORT.
                lda.# es_refill1 
                jmp error 


quit_refill_successful
                ; Assume we have successfully accepted a string of input from
                ; a source, with address of buffer in cib and length of input in
                ; ciblen. We arrive here still with the TRUE flag from REFILL as
                ; TOS (in Y)
                ldy.dx 00       ; drop TOS
                inx
                inx
                
                ; make >IN point to begining of buffer
                stz.d toin
 
                ; Main compile/execute routine. Consider moving this inside QUIT
                ; once we know everything works 
                jsr compex

                ; Test for Data Stack underflow. Our stack is so large in single
                ; user mode that we don't bother checking for overflow - if that
                ; happens, we're screwed anyway
                cpx.# { dsp0 + 1 }
                bcc quit_ok     ; DSP must always be smaller (!) than DSP0
                
                lda.# es_underflow
                jmp error

quit_ok
                ; Display system prompt if all went well
                lda.# s_ok
                jsr print_string


                ; get next line
                jmp quit_get_line

z_cold
z_abort         
z_quit          nop  ; dummy for compilation, TODO test if required

; -------------------------------------------------------------------
; >IN "TO-IN" ( -- addr ) 6 bytes / 12 cycles
; Return address where pointer to current char in input buffer lives (>IN)
xt_to-in         
                dex
                dex
                sty.dx 00

                ldy.# toin      ; >IN
z_to-in         rts


; -------------------------------------------------------------------
; , "COMMA" ( n -- ) 11 bytes / 29 cycles
; Allot one cell and store TOS in memory. We ignore alignment issues, though
; satisfy the ANSI requirement that an aligned compiler pointer will remain
; aligned
; There is another variant possible: 
;               tya
;               ldy.d cp
;               sta.y 0000
;               iny
;               iny
;               sty.d cp
;               ldy.dx 00
;               inx
;               inx
; This is as fast as the variant below, but three bytes longer
xt_comma         
                tya
                sta.di cp       ; STA (CP)
                inc.d cp
                inc.d cp

                ldy.dx 00
                inx
                inx

z_comma         rts


; -------------------------------------------------------------------
; ! "STORE" ( n addr -- ) 9 bytes / X cycles
; Save value at designated memory location
xt_store         
                lda.dx 00       ; NOS has value
                sta.y 0000
                inx
                inx
                inx
                inx

z_store         rts


; -------------------------------------------------------------------
; @ "FETCH" ( addr -- n ) 4 bytes / 7-8 cycles
; Get one cell (16 bit) value from given address
xt_fetch         
                lda.y 0000
		tay
z_fetch         rts


; -------------------------------------------------------------------
; + "PLUS" ( n m -- n+m ) 7 bytes / X cycles
; Add TOS and NOS
xt_plus          
        .!a16
                tya
                clc
                adc.dx 00
                tay
                inx
                inx 

z_plus          rts


; -------------------------------------------------------------------
; - "MINUS" ( n m -- n-m ) 10 bytes / X cycles
; Subtract NOS from TOS
xt_minus         
        .!a16
                tya
                eor.# 0ffff

                sec             ; not CLC
                adc.dx 00 

                tay
                inx
                inx
                
z_minus         rts


; -------------------------------------------------------------------
; 0 "ZERO" ( -- 0 ) 7 bytes / 12 cycles
; Pushes the number 0000 on the Data Stack
xt_zero          
        .!xy16
                dex
                dex
                sty.dx 00 
                ldy.# 0000

z_zero          rts
               

; -------------------------------------------------------------------
; 1 "ONE" ( -- 1 ) 7 bytes / 12 cycles
; Pushes the number 1 on the Data Stack
xt_one  
        .!xy16
                dex
                dex
                sty.dx 00
                ldy.# 0001 
   
z_one           rts


; -------------------------------------------------------------------
; 1- "ONE-MINUS" ( n -- n-1 ) 1 byte / 2 cycles
; Subtract 1 from Top of Stack (TOS). Because there is no checking if there is
; actually anything on the Data Stack, this routine will fail silently if the
; stack is empty
xt_one-minus      
        .!xy16
                dey
z_one-minus     rts


; -------------------------------------------------------------------
; 1+ "ONE-PLUS" ( n -- n+1 ) 1 byte / 2 cycles
; Add 1 to TOS. Because there is no checking if there is actually anything on
; the Data Stack, this routine will fail silently if the stack is empty
xt_one-plus      
        .!xy16
                iny
z_one-plus      rts


; -------------------------------------------------------------------
; 2 "TWO" ( -- 2 ) 7 bytes / 12 cycles
; Pushes the number 2 on the Data Stack
xt_two           
        .!xy16
                dex
                dex
                sty.dx 00
                ldy.# 0002 
   
z_two           rts


; -------------------------------------------------------------------
; 2* "TWO-STAR" ( n -- 2*n ) 3 bytes / 6 cycles
; Multiply Top of Stack (TOS) by 2. This is also used by CELLS
xt_two-star      
	.!a16
	.!xy16
                tya
                asl.a
                tay
                
z_two-star      rts


; -------------------------------------------------------------------
; 2DROP ( n m -- ) 6 bytes / 13 cycles
; Drop first two entries of Data Stack
xt_2drop         
                ldy.dx 02
                inx
                inx
                inx
                inx

z_2drop         rts


; -------------------------------------------------------------------
; 2DUP ( n m -- n m n m ) 10 bytes / 23 cycles
; Duplicated the top two data stack entries

xt_2dup          
        .!xy16
                dex
                dex
                dex
                dex
                sty.dx 02
                lda.dx 04
                sta.dx 00

z_2dup          rts


; -------------------------------------------------------------------
; ' "TICK" ( "string" -- xt ) X bytes / X cycles
; Given a string with the name of a word, return the word's execution token (xt)
; Abort if not found
xt_tick          
		jsr xt_parse-name	; ( -- addr u ) 

		; if we got a zero, complain and abort
                tya                     ; force flag check
                bne tick_have_word

                lda.# es_noname
                jmp error

tick_have_word
                jsr xt_find-name        ; ( addr u -- nt)
                tya                     ; force flag check

                ; if we didn't find string in the dictionary, complain and abort
                bne tick_have_nt

                lda.# es_syntax
                jmp error
                
tick_have_nt
                jsr xt_name-int            ; ( nt -- xt ) 
                
z_tick          rts


; -------------------------------------------------------------------
; ABS ( n -- u ) 8 bytes / X cycles
; Return the absolute value of a single number
xt_abs           
        .!a16
        .!xy16
                tya             ; force flag test
                bpl z_abs       ; positive number is easy

                ; negative: Calculate 0-n
                eor.# 0ffff 
                inc.a
                tay
                
z_abs           rts

; -------------------------------------------------------------------
; ACCEPT ( addr n1 -- n2 ) X bytes / X cycles
; Receive a string of at most n1 characters, placing them at addr. Return the
; actual number of characters as n2. Characters are echoed as they are received.
; ACCEPT is called by REFILL these days. 
xt_accept        
                ; Set up loop
                tya             ; force flag test
                bne accept_nonzero
                                
                ; if we were told to get zero chars, just quit
                inx             ; NIP, TOS is zero which is also FALSE
                inx

                rts

accept_nonzero
                lda.dx 00       ; address of buffer is NOS
                sta.d tmp1
                inx             ; NIP 
                inx

                sty.d tmp2      ; Save max number of chars in tmp2
                ldy.# 0000      ; Use Y as counter
        .a8

accept_loop
                ; TODO rewrite with KEY so we can revector it
                ; We don't need to check for CTRL-l, because a vt100 terminal
                ; clears the screen automatically
                jsr get_chr
       .!a8 
                ; we quit on both line feed and carriage return
                cmp.# AscLF     
                beq accept_eol
                cmp.# AscCR
                beq accept_eol

                ; BS and DEL do the same thing for the moment
                cmp.# AscBS     
                beq accept_bs
                cmp.# AscDEL
                beq accept_bs
  
                ; CTRL-c and ESC abort (see if this is too harsh)
                cmp.# AscCC     
                bne + 
                jmp xt_abort
@
                cmp.# AscESC
                bne + 
                jmp xt_abort
@
                ; CTRL-p will be used for "previous cmd", TODO
                cmp.# AscCP     
                bne +
        .a16
                lda.# tests_prev_cmd
                jsr print_string
        .a8
                bra accept_loop
@
                ; CTRL-n will be used for "next cmd", TODO 
                cmp.# AscCN
                bne +
        .a16
                lda.# tests_next_cmd
                jsr print_string
        .a8
                bra accept_loop

@
                ; That's quite enough, echo character
                ; TODO change to EMIT 
                jsr put_chr     ; echo character
        .!a8
                ; TODO multitasking: Add PAUSE here (or in EMIT)

                sta.diy cib     ; STA (CIB),Y
                iny
                cpy.d tmp2      ; reached character limit?
                bne accept_loop ; fall thru if buffer limit reached

accept_eol
                sty.d ciblen    ; Y contains number of chars accepted already
        .a16
                jsr xt_space     ; print final space
                rts             ; this is the actual return of the routine

accept_bs
        .!a8
                cpy.# 0000      ; buffer empty?
                bne +

                lda.# AscBELL   ; complain and don't delete beyond the start of line
                jsr put_chr
                iny
@
                dey
                lda.# AscBS     ; move back one
                jsr put_chr    
                lda.# AscSP     ; print a space (rubout) 
                jsr put_chr
                lda.# AscBS     ; move back over space
                jsr put_chr

                bra accept_loop

z_accept        rts

; -------------------------------------------------------------------
; ALLOT ( n -- ) X bytes / X cycles
; Reserve a certain number of bytes (not cells) or release them. If n = 0, do
; nothing. If n is negative, release n bytes, but only to the beginning of the
; Dictionary. If n is positive (the most common case), reserve n bytes, but not
; past the Dictionary.
; See http://forth-standard.org/standard/core/ALLOT
; TODO test negative values
xt_allot         
        .!a16
                tya                     ; force flag check
                beq allot_real_gone     ; zero bytes, don't do anything 
                bmi allot_minus         ; free memory instead of reserving it

                ; most common case: reserve n bytes. We've already transfered
                ; TOS to A, so we just have to add the current compile pointer
                clc
                adc.d cp                ; create new CP
                bcs allot_error         ; oops, we've wrapped

                tay                     ; save copy of new CP

                sec
                sbc.# maxram-single     
                bmi allot_done          ; oops, fall thru if beyond max RAM

allot_error
                lda.# es_allot
                jmp error

allot_minus
                ; negative value means we're freeing memory 
                sec
                sbc.d cp
                bcc allot_error         ; oops, we've wrapped

                tay

                sbc.# cp0               ; Carry Flag must still be set
                bmi allot_error         ; oops, gone too far back
                
                ; fall through to allot_done
allot_done      
                sty.d cp        ; new compiler pointer
allot_real_gone
                ldy.dx 00       ; DROP
                inx
                inx

z_allot         rts


; -------------------------------------------------------------------
; BELL ( -- ) X bytes / X cycles
; Trigger terminal bell on vt100 terminals
; TODO replace with EMIT
xt_bell          
	.!a16
		lda.# AscBELL 
		jsr put_chr

z_bell          rts


; -------------------------------------------------------------------
; BL ( -- u ) 7 bytes / 12 cycles
; Put ASCII char for SPACE on Data Stack
xt_bl            
        .!xy16
                dex
                dex
                sty.dx 00
                ldy.# AscSP

z_bl            rts

; -------------------------------------------------------------------
; BYE ( -- ) 2 bytes / 7-8 cycles
; Leave Liara Forth, returning to Mensch Monitor
xt_bye           
		cli
		brk 00  ; status byte 00 required for assembler

z_bye           rts     ; dummy for compiling, never reached


; -------------------------------------------------------------------
; CELLS ( n -- n ) X bytes / X cycles
; Given a number of cells, return the number of bytes that they will require.
; This is 16 bit cell Forth, so the value returned by this word is the same as
; returned by 2*, see there. 


; -------------------------------------------------------------------
; CONSTANT ( "name" n -- ) X bytes / X cycles
; Associate a fixed value with a word. This could be realized as 
; CREATE , DOES> @  as well. We do more in assembler but let CREATE do the heavy
; lifting. 
; See http://www.bradrodriguez.com/papers/moving3.htm for a primer on how
; this works in various Forths. 
xt_constant      
                jsr xt_create

                ; CREATE by default installs a subroutine jump to DOVAR, but we
                ; actually want DOCONST this time. Go back two bytes and repace
                ; the subroutine jump target
                lda.d cp
                dec.a
                dec.a
                sta.d tmp1

                lda.# doconst
                sta.di tmp1     ; STA (TMP1)

                ; Save TOS in next cell. This is a direct version of COMMA
                tya             ; there is no "sty.di cp"
                sta.di cp
                inc.d cp
                inc.d cp

                ldy.dx 00       ; DROP
                inx
                inx

z_constant      rts


; -------------------------------------------------------------------
; COUNT ( c-addr -- addr u ) 14 bytes / X cycles
; Convert old-style character string to address-length pair. Note that the
; length of the string c-addr ist stored in character length (8 bit), not cell
; length (16 bit). This is rarely used these days, though COUNT can also be used
; to step through a string character by character. 
xt_count         
        .!a16
        .!xy16
                tya
                inc.a           ; String address starts one char later

                dex
                dex
                sta.dx 00       ; NOS
                
                lda.y 0000      ; LDA $0000,Y  first byte is length
                xba             ; move length to LSB
                and.# 00ff      ; get rid of whatever was MSB
                tay             ; TOS
                
z_count         rts


; -------------------------------------------------------------------
; CR ( -- ) X bytes / X cycles
; Cause following output to appear at beginning of next line
; TODO replace with EMIT
xt_cr            
                lda.# AscLF     ; test with AscCR for emulators
                jsr put_chr

z_cr            rts

; -------------------------------------------------------------------
; CREATE ( "name" -- ) X bytes / X cycles
; Create a Dictionary entry associated with "name", used for various words,
; especially for VARIABLE. When called, this new word will return the associated
; address.
xt_create        
        .!a16
                jsr xt_parse-name        ; ( -- addr u ) 
                bne create_got_name

                ; if we got a zero-length name string, complain and abort
                lda.# es_noname
                jmp error 

create_got_name
                ; all Dictionary entries are lowercase
                jsr string_to_lowercase 

                ; Remember the first free byte of memory as the start of the new
                ; word
                lda.d cp
                sta.d tmp1              ; save start of new word

                ; Enforce limit on 255 char length names by masking the MSB
                ; of the length of the given string. We arrive here with 
                ; ( addr u ) 
                tya
                and.# 00ff
                sta.d tmp2      ; save length of name string

                ; We need 8 bytes + the length of the name string for our new
                ; header. This is also the offset for the start of the code
                ; field (the xt_ label) so we need to remember it. Otherwise, we
                ; could just allot the space afterwards. 
                clc
                adc.# 0008
                sta.d tmp3      ; total bytes required for header

                ; We need to allocate three more bytes for the hardcoded
                ; code field area (CFA), the "payload" of the word which by
                ; default will be a subroutine jump to DOVAR
                inc.a
                inc.a
                inc.a

                ; Instead of jumping to ALLOT, we do things by hand for speed
                ; and so we don't have to fool around with the stack
                clc
                adc.d cp
                sta.d cp 

                ; Now we walk through the header, using Y as the index. See
                ; drawing of header in headers.tasm file for reference. We
                ; arrive here with ( addr u ) still from PARSE-NAME. We need
                ; that addr later for the name string, so we push it to the
                ; Return Stack. We'll clean up the Data Stack later
                lda.dx 00
                pha

                ; HEADER BYTES 0,1: Length byte and flags
                ldy.# 0000      ; Y is now an index, not TOS
                lda.d tmp2      ; get length byte
                sta.diy tmp1    ; STA (TMP1),Y
                iny
                iny

                ; BYTES 2,3: Next word in the dictionary (its nt). This is the
                ; current Dictionary Pointer
                lda.d dp
                sta.diy tmp1
                iny
                iny
                
                ; BYTES 4,5: Start of code field (xt of this word, "xt_" link)
                ; This begins after the header, so we take the length of the
                ; header, which we saved in tmp3, and use it as an offset to 
                ; the address of the start of the word
                lda.d tmp1      ; can't use CP, because we've allotted space
                sta.d dp        ; while we've got it, make old CP the new DP

                clc
                adc.d tmp3      ; total header length
                sta.diy tmp1
                iny
                iny
               
                ; BYTES 6,7: End of code ("z_" link)
                ; By default, we execute a jump to the DOVAR routine, so we need
                ; to move three bytes down, and then one more byte so the z_
                ; label points to the (fictional) RTS instruction for correct
                ; compilation. The start of the code field is still in A
                inc.a
                inc.a
                inc.a
                sta.diy tmp1
                iny
                iny

                ; BYTE 8: Start of name string
                ; The addr of the string is on the Return Stack, the length of
                ; the name string is in tmp2. We subtract eight from the address
                ; so we can use the same loop index
                pla             ; get back string address
                sec
                sbc.# 0008
                sta.d tmp3
        .a8
@
                lda.diy tmp3 
                sta.diy tmp1
                iny
                dec.d tmp2
                bne - 

                ; After the name string, comes the Code Field (start at xt, that
                ; is, the xt_ label of the word) which is initially a jump to the
                ; subroutine to DOVAR. We're still in 8-bit A-register, which is
                ; good
                lda.# 20        ; opcode of JSR
                sta.diy tmp1
                iny             ; single increase only because we have 8-bit A 

                lda.# .lsb dovar 
                sta.diy tmp1
                iny

                lda.# .msb dovar
                sta.diy tmp1

        .a16
                ; We're done. Restore Data Stack (2DROP)
                ldy.dx 02
                inx
                inx
                inx
                inx
                
z_create        rts


; -------------------------------------------------------------------
; DEPTH ( -- u ) 14 bytes / X cycles
; Push the number of entries in cells (not bytes) on the parameter stack.
; Assumes X is valid as the DSP.
xt_depth         
        .!a16
		; We've got zero entries when X is dsp0
                stx.d tmpdsp
                lda.# dsp0
                sec
                sbc.d tmpdsp

                ; now divide by two because each cells is to bytes long
                lsr.a

                dex
                dex
                sty.dx 00

                ; push result to stack
                tay

z_depth         rts

; -------------------------------------------------------------------
; DOT ( n -- ) X bytes / X cycles
; Print value that is TOS followed by a single space
; Forth code is  DUP ABS 0 <# #S ROT SIGN #> TYPE SPACE 
; Since this is used interactively, and humans are slow (just ask GlaDOS), we
; focus on size
; TODO this is a temporary version
xt_dot           
                ; --- TEMP print routine ---
                tya
                and.# 0ff00
                xba 
                jsr byte_to_ascii
                tya
                and.# 00ff
                jsr byte_to_ascii
                jsr xt_space
                ; --- TEMP print routine ---
                
                ; Since we don't care about speed in this word, we save one byte
                ; by doing DROP the slow way and save one byte
                jsr xt_drop
                
z_dot           rts


; -------------------------------------------------------------------
; DOTPAREN ( "string" -- ) 13 bytes / X cycles
; Display string delimited by ")" immediately, regardless if word is compiled or
; interpreted. Forth definition is  .( [CHAR] ) PARSE TYPE ; IMMEDIATE
xt_dotparen     
               ; use PARSE to find the end of the string
               dex
               dex
               sty.dx 00
               ldy.# ')'

               jsr xt_parse      ; ( -- addr u) 
               jsr xt_type

z_dotparen     rts


; -------------------------------------------------------------------
; DOTS ".S" ( -- ) X bytes / X cycles
; Print content of Data Stack non-distructively. Since this is for humans, we
; don't have to worry about speed. We follow the format of Gforth
; and print the number of elements first in brackets, followed by the Data Stack
; content (if present).
xt_dots          
        .!a16
        .!xy16
                jsr xt_depth             ; ( -- u)

                ; Print stack depth in brackets
                ; TODO rewrite this to use EMIT
                lda.# '<'
                jsr put_chr

                ; --- TEMP print routine ---
                tya
                and.# 0ff00
                xba 
                jsr byte_to_ascii
                tya
                and.# 00ff
                jsr byte_to_ascii
                ; --- TEMP print routine ---

                ; TODO rewrite this to use EMIT
                lda.# '>'
                jsr put_chr
                jsr xt_space


                ; There will be a lot of cases where .S is used when the stack
                ; is empty. Get them first and exit quickly
                tya                     ; force flag test
                beq dots_done

dots_not_empty
                ; We have at least one element on the stack, which used to be in
                ; Y as TOS, but is now NOS and therefore accessable by X. Also,
                ; the depth of the Data Stack is already in Y waiting to be used
                ; as a counter. We use this to our advantage. 
                
                ; Normally we would go with STX.D tmptos / LDX.D tmptos with
                ; 4 bytes and 8 cycles because we value speed over size.
                ; However, .S is used interactively, and humans
                ; won't notice the one cycle more of PHX/PLX (2 bytes,
                ; 9 cycles). We save the two bytes.
                phx

                ; We print from the bottom up. Note that the Data Stack locations
                ; dsp0 and dsp0+2 always contain garbage so they can be skipped,
                ; see docs/INTERNALS.md for more details 
                ldx.# dsp0      ; points to dsp0, which is garbage
                dex
                dex             ; points to dsp0-2, which is more garbage
                
dots_loop
                dex             ; get next element on DS, initially dsp0-4
                dex             

                ; --- TEMP print routine ---
                ; TODO call EMIT
                lda.dx 00
                and.# 0ff00
                xba 
                jsr byte_to_ascii
                lda.dx 00
                and.# 00ff
                jsr byte_to_ascii
                jsr xt_space
                ; --- TEMP print routine ---

                dey
                bne dots_loop

                plx             ; restore original DSP

dots_done
                ; Clean up. Again, we don't care about speed in this
                ; word so we save one byte by doing DROP the slow way
                jsr xt_drop

z_dots          rts


; -------------------------------------------------------------------
; DROP ( n -- ) 4 bytes / 9 cycles
; Drop first entry on Data Stack

xt_drop          
        .!xy16
                ldy.dx 00 
                inx
                inx

z_drop          rts


; -------------------------------------------------------------------
; DUMP ( addr u -- ) X bytes / X cycles
; Print region of memory in a pretty way. 
; TODO This is a crude, temporary version for testing. Rewrite ASAP
xt_dump          
                ; we use tmp1 as a counter because we need Y for other
                ; stuff
                sty.d tmp1

dump_line_loop
                jsr xt_cr
                
                ; start internal counter for 16 numbers per row
                ldy.# 0010
dump_byte_loop
                ; if there are zero bytes left to display, we're done
                lda.d tmp1
                beq dump_done

                ; otherwise, print contents pointed to by address in NOS
                lda.dxi 00
                jsr byte_to_ascii       ; TODO replace by EMIT
                jsr xt_space

                ; next character
                inc.dx 00

                ; loop counter
                dec.d tmp1
                dey
                bne dump_byte_loop
                bra dump_line_loop
                
dump_done
                jsr xt_cr 

                ; drop everything and return
                ; TODO replace by call of 2DROP
                ldy.dx 02
                inx
                inx
                inx
                inx
                
z_dump          rts


; -------------------------------------------------------------------
; DUP  ( n -- n n ) 4 bytes / 9 cycles
; Duplicate first entry on Data Stack

xt_dup           
        .!xy16
                dex
                dex
                sty.dx 00

z_dup           rts


; -------------------------------------------------------------------
; EVALUATE ( addr u -- ) X bytes / X cycles
; Execute string. Set SOURCE-ID to -1, make addr u the input source, 
; set >IN to zero. After processing the line, revert to old input source. 
xt_evaluate      
                ; We follow pforth's procedure of pushing SOURCE, SOURCE-ID, and
                ; >IN to the Return Stack
                lda.d toin      ; >IN
                pha
                lda.d insrc     ; Input Source (SOURCE-ID)
                pha
                lda.d cib
                pha
                lda.d ciblen
                pha

                ; set SOURCE-ID to -1
                lda.# 0ffff
                sta.d insrc

                ; set >IN to zero
                stz.d toin

                ; move TOS and NOS to input buffers
                sty.d ciblen
                lda.dx 00
                sta.d cib

                ; dump address string from stack
                ldy.dx 02
                inx
                inx
                inx
                inx

                jsr compex

                ; restore state from before evaluate
                pla
                sta.d ciblen
                pla
                sta.d cib
                pla
                sta.d insrc
                pla
                sta.d toin
                
z_evaluate      rts


; -------------------------------------------------------------------
; EXECUTE ( xt -- ) X bytes / X cycles
; Run a word with help of its xt on the TOS

; Reserve three bytes for the jump - three in case we want to expand to the full
; range
; TODO move this to someplace that is assured to be RAM, not possibly ROM
execute_ip      .byte 00, 00, 00    

xt_execute       
        .!a16
        .!xy16
		; Store the xt for later use and then drop it off the stack
		sty execute_ip
                ldy.dx 00
                inx
                inx

                ; Only JMP has the addressing mode we need. All our Forth
                ; words end with a RTS instruction, so they will take us back to
                ; the original caller of this routine without us having to muck
                ; about with the Return Stack. 
                jmp.i execute_ip        ; JMP (EXECUTE_IP)
  
z_execute       nop             ; Never reached, see if we need the NOP
                

; -------------------------------------------------------------------
; FALSE ( -- f ) 7 bytes / 12 cycles
; Pushes value $0000 for Forth true on Data Stack. This is the same code as for 
; ZERO, see there. Dictionary entry should have xt_zero/z_zero instead of
; xt_false/z_false

; -------------------------------------------------------------------
; FIND-NAME ( addr u -- nt | 0 ) 91 bytes / X cycles
; Given a string, find the Name Token (nt) of a word or return zero if the word
; is not in the dictionary. We use this instead of ancient FIND to look up words
; in the Dictionary passed by PARSE-NAME. Note this returns the nt, not the xt
; of a word like FIND. To convert, use NAME>INT. This is a Gforth word. See
; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html 
; FIND calls this word for the hard word
xt_find-name     
                ; We abort when we get an empty string, that is, one with
                ; a length of zero TOS. We could test for this, but it will
                ; happen so rarely that the speed penalty is higher if we run
                ; the test for every single call. Looking for an empty string
                ; does force us to check the whole dictionary, though. The test
                ; would be 3 bytes and 4 to 6 cycles longer: 
                ;       tya                     ; force flag check
                ;       beq find-name_failure
        .!a16
        .!xy16
                ; set up loop for the first time
                sty.d tmptos    ; length of mystery string in tmptos, Y now free

                ldy.d dp
                sty.d tmp1      ; nt of first Dictionary word 

                ldy.dx 00 
                sty.d tmp2      ; address of mystery string, was NOS

find-name_loop
                ; First quick test: Are strings the same length?
                lda.di tmp1     ; LSB in first header word is length
                and.# 00ff      
                cmp.d tmptos    ; we test LSB
                ; Most of the time, it will not be the same, so we save one
                ; cycle pro loop if we only take the branch when they are the
                ; same
                beq find-name_chars

find-name_next_entry
                ; next header address is two bytes down
                inc.d tmp1
                inc.d tmp1
                lda.di tmp1     ; LDA (TMP1) 

                ; a zero entry marks the end of the Dictionary
                beq find-name_failure_16

                sta.d tmp1      ; new header 
                bra find-name_loop

find-name_chars
                ; Yes, same length, so we compare characters

                ; Switch A to 8 bit for this 
        .a8
                ; Second quick test: Check first char, which is 8 bytes into the
                ; header 
                ldy.# 0008
                lda.diy tmp1    ; LDA (TMP1),Y - first char of entry
                cmp.di tmp2     ; CMP (TMP2) - first char of mystery string
                beq find-name_all_chars
                
find-name_char_nomatcnt_8
                ; First char is not the same, next entry
        .a16
                bra find-name_next_entry

find-name_all_chars
        .!a8
                ; String length is the same, and the first character is the
                ; same. If the word is only one character long, we're done
                ldy.d tmptos
                dey             ; faster and shorter than CPY.# 01
                beq find-name_success
                
                ; No such luck: The strings are the same length and the first
                ; char is the same, but the word is more than one char long. So
                ; we suck it up and compare every single character. We go from
                ; back to front, because words like CELLS and CELL+ would take
                ; longer otherwise. We can also shorten the loop by one because
                ; we've already compared the first char. 

                ; Even worse, we have to add 8 bytes to address of Dictionary
                ; string to allow testing with one loop. We need this like
                ; a hole in the head because we just switched A to 8 bit.
                ; However, staying with an 8-bit A is even slower.
        .a16
                lda.d tmp1      ; address of Dictionary string
                clc
                adc.# 0008 
                sta.d tmp3
        .a8
                ldy.d tmptos    ; get length of strings as loop index
                dey             ; first index is length minus 1

@
                lda.diy tmp2    ; LDA (TMP2),Y - last char of mystery string
                cmp.diy tmp3    ; CMP (TMP1),Y - last char of DP string
                bne find-name_char_nomatcnt_8
                dey             ; start of string (Y=0) was already tested
                bne -
                
find-name_success
                ; If we reach here, the strings are the same and we have a match
                ; We get here with an 8 bit A
        .a16    
                ldy.d tmp1      ; get the correct DP
                bra find-name_done


find-name_failure_16
                ; Word not found in Dictionary, return zero. Assumes A is 16
                ; bit
                ldy.# 0000      ; fall thru 

find-name_done
                inx             ; drop old address (NIP)
                inx

z_find-name     rts


; -------------------------------------------------------------------
; HERE ( -- u ) 6 bytes / 13 cycles
; Push Compiler Pointer address on the Data Stack
xt_here          
        .!a16           ; paranoid
        .!xy16
                dex
                dex
                sty.dx 00

                ldy.d cp

z_here          rts

; -------------------------------------------------------------------
; NAME>INT ( nt -- xt ) 4 bytes / 8 cycles
; Given the Name Token (nt) of a word, return its Execute Token (xt)
xt_name-int      
        .!a16
        .!xy16
		; The xt of a word beginns four bytes down from its nt
		iny
		iny
		iny
		iny
                lda.y 0000
                tay
                
z_name-int      rts

; -------------------------------------------------------------------
; NAME>STRING ( nt -- addr u ) 16 bytes / X cycles
; Given a name token (nt) of a word, return its string. This is a Gforth word
; that works with the Dictionary header entries. It is not checked if nt is
; a valid name token. 
xt_name-string   
        .!a16
        .!xy16
                dex             ; move NOS down one
                dex

                ; the name string of a word begins 8 bytes down from its nt,
                ; which we have as TOS
                tya
                clc
                adc.# 0008
                sta.dx 00       ; NOS
                
                ; the length of the name string is in the LSB of the first word
                ; of the dictionary entry header (the name token)
                lda.y 0000      ; LDA $0000,Y
                and.# 00ff      ; mask all but length byte
                tay
                
z_name-string   rts


; -------------------------------------------------------------------
; NIP ( n m -- m ) 2 bytes / 4 cycles
; Delete entry that is NOS
xt_nip           
        .!xy16
                inx
                inx
z_nip           rts


; -------------------------------------------------------------------
; OVER ( n m -- n m n )  6 bytes / 14 cycles
; Push NOS on Data Stack
xt_over          
                dex 
                dex
                sty.dx 00
                ldy.dx 02
		
z_over          rts


; -------------------------------------------------------------------
; PAD ( -- addr ) 11 bytes / X cycles
; Return address to a temporary area in free memory for user. Must be at least 
; 84 bytes in size (says ANSI). It is located relative to the compile area
; pointer (CP) and therefore varies in position. This area is reserved for the
; user and not used by the system
xt_pad           
        .!a16
                dex
                dex
                sty.dx 00

                lda.d cp
                clc
                adc.# padoffset
                tay
                
z_pad           rts


; -------------------------------------------------------------------
; PAGE ( -- ) X bytes / X cycles
; Clear the screen on vt-100 terminals by sending the code "ESC[2J". This is
; only useful in interactive scenarios so we don't worry about speed
; TODO rewrite with EMIT
xt_page          
                lda.# vt100_page
                jsr print_string

                ; In theory, this should have moved the cursor to the top left
                ; corner ("home"), but this doesn't seem to work in practice.
                ; So we send "ESC[H" as well.
                lda.# vt100_home
                jsr print_string
                
z_page          rts

; -------------------------------------------------------------------
; PARSE-NAME ( "name" -- addr u ) 41+ bytes / X cycles
; Find next word in input string, skipping leading spaces. This is a special
; form of PARSE and drops through to that word. See PARSE for more detail. We
; use this word internally for the interpreter because it is a lot easier to use
; http://forth-standard.org/standard/core/PARSE-NAME has a Forth implementation
xt_parse-name    
        .!a16
        .!xy16
                ; skip leading spaces, changing >IN, then place SPACE 
                ; character on data stack for PARSE
                phy                     ; save TOS for later use
                ldy.d toin              ; >IN 
        .a8
parse-name_loop
                cpy.d ciblen            ; end of line?
                beq parse-name_empty_line

                lda.diy cib             ; LDA (CIB),Y
                cmp.# AscSP
                bne parse-name_found
                iny
                bra parse-name_loop

parse-name_empty_line
        .a16    
                ; The Gforth documentation does not say what address is returned
                ; if a string with only spaces is returned. Experiments with 
                ; the word  : PNT ( "name" -- ) PARSE-NAME SWAP U. U. TYPE ; 
                ; show that it returns the address of the last space in the
                ; input, which is cib+ciblen. So we do that as well. 
                dex
                dex
                dex
                dex

                ply                     ; restore old TOS as 3OS
                sty.dx 02

                lda.d cib
                clc
                adc.d ciblen
                sta.dx 00               ; Address as NOS

                ldy.# 0000              ; TOS 

                rts                     ; don't have to go through PARSE

parse-name_found
        .!xy16
        .a16
                sty.d toin              ; new >IN

                ply                     ; recover TOS
                dex
                dex
                sty.dx 00

                ldy.# AscSP             ; put space on TOS for PARSE

                ; fall thru to PARSE
                
; -------------------------------------------------------------------
; PARSE ( c "name" -- addr u ) 45 bytes / X+ cycles
; Find word in input string delimited by character given Do not skip leading
; delimiters, this is an important difference to PARSE-NAME. PARSE and
; PARSE-NAME replace WORD in modern systems. See the ANSI documentation at
; http://www.forth200x.org/documents/html3/rationale.html#rat:core:PARSE 
; PARSE-NAME drops through to here
;
;    cib   cib+toin    cib+ciblen
;     v       v             v
;     |#####################|              Length of found string: 
;                                          ciblen - toin
;     +------>|  toin (>IN)
;     +-------------------->|  ciblen
;
; The input string is stored starting at the address in the Current Input Buffer
; (CIB), the length of which is in CIBLEN. While searching for the delimiter,
; TOIN (>IN) points to the where we currently are. Since PARSE does not skip
; leading delimiters, we assume we are on a useful string.
xt_parse         
        .!a16
        .!xy16
                sty.d tmp1      ; save delimiter, char is LSB

                ; save beginning of new word (cib+toin) to NOS. Don't need to
                ; worry about TOS because Y gets clobbered anyway before we
                ; return
                lda.d toin
                sta.d tmp3      ; save >IN for later length calculation
                clc
                adc.d cib

                dex             ; save addr as NOS
                dex
                sta.dx 00

                stz.d tmp2      ; offset for EOL/char found adjustment of >IN

                ; prepare loop using Y as index
                ldy.d toin
        .a8

parse_loop
                cpy.d ciblen    ; check for EOL first
                beq parse_reached_eol

                lda.diy cib     ; LDA (CIB),Y
                cmp.d tmp1      ; found delimiter?
                beq parse_found_delimiter
                iny
                bra parse_loop

parse_found_delimiter
                ; If we haven't reached the end of the line, but found
                ; a delimiter, we want >IN to point to the next character after
                ; the delimiter, not the delimiter itself. This is what the
                ; offset is for
        .a16
                inc.d tmp2      

parse_reached_eol       
                ; calculate length of string found (see ascii drawing)
        .!xy16
        .a16
                tya             
                sec
                sbc.d tmp3      ; original value for >IN / index of first char
                pha             ; save so we can manipulate Y

                ; calculate new >IN
                tya
                clc
                adc.d tmp2      ; offset for EOL vs found delimiter
                sta.d toin

                ply             ; length of string in TOS

z_parse-name
z_parse         rts

; ------------------------------------------------------------------- 
; REFILL ( -- f ) X bytes / X cycles
; "Attempt to fill the input buffer from the input source, returning a true flag
; if successful. When the input source is the user input device, attempt to
; receive input into the terminal input buffer. If successful, make the result
; the input buffer, set >IN to zero, and return true. Receipt of a line
; containing no characters is considered successful. If there is no input
; available from the current input source, return false. When the input source
; is a string from EVALUATE, return false and perform no other action."
; See https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
; and Conklin & Rather p. 156
xt_refill        
        .!a16
        .!xy16
                ; We handle buffer switches here so that regardless of input
                ; source, we have access to the previous input. This is not in
                ; the ANSI specification in any way.
                lda.d cib
                eor.# 0100      ; flip 07d00 / 07c00
                sta.d cib
                
                lda.d ciblen    ; current length is now previous length
                sta.d piblen
 
                ; Get input source from SOURCE-ID. We don't have blocks in this
                ; version, or else we would have to check BLK first. This is an
                ; optimized version of a subroutine jump to SOURCE-ID
                lda.d insrc
                bne refill_src_not_kbd

                ; SOURCE-ID of zero means we're getting stuff from the keyboard
                ; with ACCEPT. 
                dex                     ; push Data Stack down twice
                dex
                sty.dx 00

                lda.d cib               ; address of current input buffer NOS
                dex
                dex
                sta.dx 00

                ldy.# buffersize 

                jsr xt_accept            ; ( addr n1 -- n2)

                ; ACCEPT returns the number of characters accepted, but we don't
                ; need them. We just overwrite TOS this with the flag
                ldy.# 0ffff

                rts

refill_src_not_kbd
                ; If SOURCE-ID doesn't return a zero, it must be a string in
                ; memory or a file (remember, no blocks in this version)
                inc.a
                bne refill_source_is_not_string

                ; Simply return FALSE flag as per specification
                dex
                dex
                sty.dx 00
                tay

                rts

refill_source_is_not_string
                ; Since we don't have blocks, this must mean that we are trying
                ; to read from a file. However, we don't have files yet, so we 
                ; report an error and jump to ABORT.
                lda.# es_refill2 
                jmp error

z_refill        rts     ; dummy for compiling


; -------------------------------------------------------------------
; ROT ( a b c -- b c a ) X bytes / X cycles
; Rotate the top three entries downwards (third entry becomes first)
; Remember this with the "R" for "revolution": The bottom entry becomes the top.
xt_rot           
        .!a16
        .!xy16
                lda.dx 00       ; save b
                sty.dx 00       ; move c to NOS
                ldy.dx 02       ; move a to TOS
                sta.dx 02       ; save b as 3OS
                
z_rot           rts


; -------------------------------------------------------------------
; SOURCE ( -- addr u ) 12 bytes / X cycles
; Return the address and size of current input buffer. Replaces TIB and #TIB in
; ANSI Forth

xt_source        dex             ; make room on Data Stack
                dex
                dex
                dex
                sty.dx 02

                lda.d cib       ; address of current input buffer as NOS
                sta.dx 00

                ldy.d ciblen    ; length of current input buffer as TOS
                
z_source        rts

; -------------------------------------------------------------------
; SOURCE-ID ( -- n ) 6 bytes / 13 cycles
; Identify the input source unless it is a block (s. Conklin & Rather p. 156).
; Since we don't have blocks (yet), this will give the input source: 0 is
; keyboard, -1 (0ffff) is character string, and a text file gives the fileid.

xt_source-id     
        .!xy16
                dex
                dex
                sty.dx 00
                ldy.d insrc
                
z_source-id     rts

; -------------------------------------------------------------------
; SPACE ( -- ) X bytes / X cycles
; Print one ASCII space character  
; TODO change to call EMIT
xt_space         
                lda.# AscSP
                jsr put_chr
        .!a16

z_space         rts


; -------------------------------------------------------------------
; SPACES ( u -- ) 12 bytes / X cycles
; Print u spaces. Calls SPACE, because this is probably interactive and humans
; are slow enough we don't have to care about speed.
xt_spaces        
        .!a16
        .!xy16
@
                dey             ; this also handles case u=0
                bmi spaces_done

                jsr xt_space
                bra - 

spaces_done
                ldy.dx 00       ; DROP
                inx
                inx

z_spaces        rts


; -------------------------------------------------------------------
; STATE ( -- addr ) 7 bytes / 12 cycles
; Return the address of a cell containing the compilation-state flag. STATE
; is true when in compilation state, false otherwise. STATE should not be 
; changed directly by the user; see
; http://forth.sourceforge.net/standard/dpans/dpans6.htm#6.1.2250
xt_state         
        .!xy16
                dex
                dex
                sty.dx 00
                ldy.# state
                
z_state         rts


; -------------------------------------------------------------------
; SWAP ( n m -- m n ) 5 bytes / 12 cycles
; Exchange TOS with NOS. We don't check if there are enough elements on the Data
; Stack; underflow errors will go undetected and return garbage.
xt_swap          
        .!a16
        .!xy16
                lda.dx 00
                sty.dx 00
                tay 

z_swap          rts

; -------------------------------------------------------------------
; TRUE ( -- f ) 7 bytes / 12 cycles
; Pushes value $FFFF for Forth true on Data Stack
xt_true          
        .!a16
        .!xy16
                dex
                dex
                sty.dx 00 
                ldy.# 0ffff

z_true          rts

; -------------------------------------------------------------------
; TUCK ( n m -- m n m ) 8 bytes / 19 cycles
; Insert TOS below NOS. We do not check if there are enough elements on the Data
; Stack, underflow will go undetected and return garbage.
xt_tuck          
        .!a16
        .!xy16
                dex
                dex
                lda.dx 2
                sta.dx 0
                sty.dx 2
                
z_tuck          rts

; -------------------------------------------------------------------
; TYPE ( addr u -- ) 23+ bytes / X cycles
; Print character string if u is not 0. We restrict all calls to put_chr and
; get_chr to make porting easier.  We call put_chr here directly instead of
; going through EMIT because EMIT will later have a PAUSE statement for
; multitasking and we probably don't want to PAUSE after every character.
; However, we'll make a final decision about that when multitasking is up and
; running.
xt_type          
        .!a16
        .!xy16
                ; just leave if u is zero (empty string)
                tya             ; force flag check of TOS
                beq type_done

                lda.dx 00       ; get address from NOS 
                sta.d tmp1
                sty.d tmp2      ; number of chars is TOS
                ldy.# 0000
        .a8
type_loop
                lda.diy tmp1    ; LDA (TMP1),Y
                jsr put_chr
                iny
                cpy.d tmp2
                bne type_loop
                
        .a16
type_done
                ; clear stack
                ldy.dx 02
                inx
                inx
                inx
                inx

                ; TODO LATER add PAUSE here for multitasking
                
z_type          rts

; -------------------------------------------------------------------
; UNUSED ( -- u ) 11 bytes / X cycles
; Return amount of memory available for the Dictionary. Does not include 
; memory for buffers, stacks etc. Does not exclude the space used by PAD
; TODO rewrite for multitasking
xt_unused        
        .!a16
                lda.# maxram-single
                sec
                sbc.d cp        ; current compile pointer 
                
                dex
                dex
                sty.dx 00

                tay
                
z_unused        rts


; -------------------------------------------------------------------
; VARIABLE ( "name" -- ) X bytes / X cycles
; Define a word that returns the address for a variable. There are various Forth
; definitions for this word, such as  CREATE 1 CELLS ALLOT  or CREATE 0 ,
; We use a variant of the second one so the variable is initialized to zero
xt_variable      
                ; We let CREATE do most of the heavy lifting
                jsr xt_create

                ; There is no "stz.di cp" so we have to do this the
                ; old way, which is still faster than a subroutine jump to ZERO
                lda.# 0000
                sta.di cp       ; STA (CP)

                inc.d cp        ; direct COMMA
                inc.d cp

z_variable      rts


; -------------------------------------------------------------------
; WORDS ( -- ) X bytes / X cycles
; Print list of all Forth words available. This only really makes sense in an
; interactive setting, so we don't have to worry about speed.
xt_words         
                jsr xt_cr        ; start on next line, this is a style choice

                lda.d dp        ; nt of first entry in Dictionary (last added)
                pha

                dex             ; create room on TOS
                dex
                sty.dx 00 

words_loop
                tay                     ; ( nt )

                jsr xt_name-string       ; ( nt -- addr u ) 
                jsr xt_type              ; ( addr u -- ) 
                jsr xt_space
        .!a16
        .!xy16
                pla

                ; the next nt is two bytes below the nt of the current one in
                ; the Dictionary header
                ;
                inc.a
                inc.a

                dex
                dex
                sty.dx 00 

                tay
                lda.y 0000              ; LDA $0000,Y
                pha
                bne words_loop          ; zero entry signals end of Dictionary

                ; all done, clean up
                pla                     ; balance MPU stack, value discarded

                ldy.dx 00
                inx
                inx

z_words         rts



; ===================================================================
; MIDDLE INCLUDES

        .include headers.tasm

; ===================================================================
; CODE FIELD ROUTINES

; ------------------------------------------------------------------- 
; DOVAR
; Execute a variable: Push the address of the first bytes of the Data Field onto
; the stack. This is called with JSR so we can pick up the address of the
; calling variable off the 65816's Return Stack. The final RTS takes us to the
; original caller of the routine that in turn called DOVAR. This is the default 
; routine installed with CREATE
dovar
        .!a16
        .!xy16
                dex             ; make room on Data Stack 
                dex
                sty.dx 00
 
                ; The address we need is stored in the two bytes after the JSR 
                ; return address, which in turn is what is on top of the Return 
                ; Stack
                ply             ; value is now TOS
                iny             ; add one because of 65816's address handling
                
                rts             ; takes us to original caller
 

; ------------------------------------------------------------------- 
; DOCONST 
; Execute a constant: Push the data in the first two byte of the Data Field onto
; the stack
doconst
        .!a16
        .!xy16
                dex             ; make room on Data Stack 
                dex
                sty.dx 00

                ; The value we need is stored two bytes after the JSR return
                ; address, which in turn is what is on top of the Return Stack
                pla             ; get the return address
                sta.d tmp1

                ; start Y as index off with 1 instead of zero because of 65816's
                ; address handling
                ldy.# 0001
                lda.diy tmp1    ; LDA (TMP1),Y
                tay

                rts             ; takes us to original caller
              

; ===================================================================
; LOW LEVEL HELPER FUNCTIONS


; ------------------------------------------------------------------- 
; COMPILE OR EXECUTE (INTERPRET)
; Core routine for interpreter called by EVALUATE and QUIT. We process one line
; only. Assumes that address of name is in cib and length of whole input 
; string is in ciblen. Consider moving this up to QUIT once we know what we are
; doing
compex
compex_loop 
                ; Normally we would use PARSE here with the SPACE character as
                ; a parameter (PARSE replaces WORD in modern Forths). However,
                ; Gforth's PARSE-NAME makes more sense as it uses spaces as
                ; delimiters per default and skips any leading spaces, which
                ; PARSE does not do.
                jsr xt_parse-name        ; ( 'string' -- addr u ) 
        .!a16
                ; if PARSE-NAME returns 0 (empty line), no characters were left
                ; in the line and we need to go get a new line
                tya             ; force flag check
                beq compex_line_done
                
                ; We let the user input words in any case, but use lower case
                ; internally (sorry, Garth).
                jsr string_to_lowercase         ; returns ( addr u )

                ; If we got something that is not a zero, we go to FIND-NAME to
                ; get the nt. Returns ( nt | 0 ) 
                jsr xt_find-name
        .!a16

                ; a zero signals that we didn't find a word in the Dictionary
                tya             ; force flag check
                bne compex_got_name_token

                ; TODO No name token, try NUMBER CONVERSION
                
                ; Woe is us, all has failed
                lda.# es_syntax         ; "Unknown word"
                jmp error

compex_got_name_token
                ; TODO see if INTERPRETED OR COMPILED
                
                ; INTERPRET WORD
                ; We arrive here with the nt as TOS. The xt of a word is
                ; four bytes farther on, so this is a quick version of NAME>INT

        .!xy16
                iny
                iny
                iny
                iny                    
                lda.y 0000              ; LDA $0000,Y
                tay
                
                jsr xt_execute

                ; that's quite enough for this word, let's get the next one
                jmp compex_loop

compex_line_done
                ; drop stuff from PARSE_NAME
                ldy.dx 02
                inx
                inx
                inx
                inx

                rts
                
; ------------------------------------------------------------------- 
; Fatal error encountered: Take address of error string from A, print it and
; then call abort
error
                jsr print_string
                jmp xt_abort

; ------------------------------------------------------------------- 
; Print a zero terminated string to the console, adding a CR character. Takes
; the address of the string in 16-bit A register, calls put_chr.  A is
; destroyed. We could probably figure out some way to use TYPE instead, but zero
; terminated strings are easier for the 65816 to use.
; TODO add version without final line feed
print_string     
        .!a16
        .!xy16
                ; don't use tmpdsp for X because we don't know if the user has
                ; used it for something already
                phx
                tax             ; x16 contains address of string
@
        .a8
                lda.x 0000      ; LDA $0000,X 
                beq print_string_done
                jsr put_chr
                inx
                bra -

print_string_done
                lda.# AscLF     ; should be CR on some systems
                jsr put_chr
        .a16
                plx
                rts

; ------------------------------------------------------------------- 
; CONVERT BYTE TO ASCII
; Convert byte in A to two ASCII hex digits and print them. Calls 
; nibble_to_ascii. Assumes A is 8 bit. 
byte_to_ascii
                pha
                ; convert high nibble first 
                lsr.a
                lsr.a
                lsr.a
                lsr.a
                jsr nibble_to_ascii

                pla
        
                ; fall thru to nibble_to_ascii


; ------------------------------------------------------------------- 
; CONVERT NIBBLE TO ASCII
; Converts the lower nibble of a number in A and returns the ASCII character
; number, then prints it. Assumes A is 8 bit
nibble_to_ascii
                and.# 000f
                ora.# '0'
                cmp.# 003a       ; '9' + 1
                bcc +
                adc.# 0006
@
                jsr put_chr
        .!a16
                rts

; ------------------------------------------------------------------- 
; Convert a string given by ( addr u ) to lowercase in place. Since we have to
; treat the input buffer as read-only by ANS rules, we have to put the converted
; string somewhere and then return the new address and length
string_to_lowercase
                ; TODO CODE THIS
                rts


; ===================================================================
; HIGH-LEVEL WORDS 

; These are executed during start up. Remember that we have to put a space at
; the end of the line if there is another line with code following it. No zero
; or CR/LF is required
hi-start
        .byte ".( Liara Forth for the W65C265SXB )"
        .byte "cr .( Version PRE-ALPHA 14. Feb 2017)"
        .byte "cr .( Scot W. Stevenson <scot.stevenson@gmail.com>)"
        .byte "cr .( Liara Forth comes with absolutely NO WARRANTY)"
        .byte "cr .( Type 'bye' to exit) cr"
hi-end


; ===================================================================
; BOTTOM INCLUDES

        .include strings.tasm

; ===================================================================
; TESTING ROUTINES (UNCOMMENT FOR USE)
                
                ; --- TODO TESTING (PRINT ONE "A") ---
                ; lda.# 61
                ; jsr put_chr
                ; .!a16
                ; brk 00
                ; --- TODO TESTING ---
                 
                ; --- TESTING SHOW WHAT IS TOS --- 
                ; tya
                ; and.# 0ff00
                ; xba 
                ; jsr byte_to_ascii
                ; tya
                ; and.# 00ff
                ; jsr byte_to_ascii
                ; jsr xt_cr
                ; --------------------------------
               
                ; --- TODO TESTING (HALT CPU) ---
                ; brk 00 ; BRK for 265sxb tests (drops back to Mensch Monitor)
                ; stp    ; STP for crude65816 emulator tests
                ; --- TODO TESTING ---
                

; ===================================================================
; END

        .end
