; Liara Forth for the W65C265SXB
; Scot W. Stevenson <scot.stevenson@gmail.com>
; First version: 01. Apr 2016
; This version: 27. Dec 2016

; This code is written in Typist's Assembler Notation for the 65c02/65816
; See docs/MANUAL.md for more information

        .mpu 65816
;       .origin 8000    ; start of code if saved to Flash memory
        .origin 6000    ; start of code if saved to built-in RAM

; ===================================================================
; TOP INCLUDES

        .include definitions.tasm


; ===================================================================
; DICTIONARY ROUTINES

; Word code routines are sorted alphabetically, except for the first three
; - COLD, ABORT, and QUIT - which flow into each other.  The byte and cycle
; values are calculated without the RTS instruction.


; -------------------------------------------------------------------
; COLD ( -- ) X bytes / X Cycles
; Reboot the system. TODO determine how to compile this word

a_cold  
        .native
        .axy16
                sei

                ; TODO switch to Single Task mode
                ; TODO set up Direct Page stuff
                ; TODO set up CP
                ; TODO set up DP
                ; TODO initiate TIB
                ; TODO initiate PAD
                ; TODO initiate User variables
                ; TODO initiate high-level words 
                
                ; start with first input buffer
                ; TODO see if we need this here or below
                lda.# buffer1
                sta.d cib
;               jsr clearbuffer 

                cli             ; PUT_CHR in printstring uses interrupts

                ; print boot strings
                lda.# s_title
                jsr printstring
                lda.# s_version
                jsr printstring
                lda.# s_author
                jsr printstring
                lda.# s_disclaimer
                jsr printstring
                lda.# s_typebye
                jsr printstring
                
                ; drop through to QUIT

; -------------------------------------------------------------------
; ABORT ( -- ) 6+ bytes / 6+ cycles
; Reset the parameter (data) stack pointer and continue as QUIT 
; We can jump here via subroutine because we reset the stack pointer
; anyway. Flows into QUIT.

a_abort         ; clear Data Stack
                ldy.# 0000
                ldx.# dsp0

; drops through to QUIT; z_abort is the same as z_quit.

; -------------------------------------------------------------------
; QUIT ( -- ) X bytes / X cycles
; Reset the input, clearning Return Stack. Jumps to QUIT do not have to be
; subroutine jumps as the Return Stack is cleared anyway. Liara Forth follows
; the ANSI Forth recommendation to use REFILL. Note we don't display the "ok"
; system prompt until after the first output.
                
a_quit          ; clear Return Stack
                lda.# stack0
                tcs

                ; switch SOURCE-ID to zero (keyboard input)
                stz.d insrc
                
                ; switch to interpret state (STATE is zero)
                stz.d state
               
                ; start with first input buffer
                lda.# buffer1
                sta.d cib
                jsr clearbuffer

quit_main_loop
                ; accept a line from the current input source
                jsr a_refill
                
                tya ; force flag test
                bne quit_refill_ok

                ; If REFILL returned a FALSE flag, something went wrong and we
                ; need to print an error message and reset the machine. We don't
                ; need to save A because we're going to clober it anyway when we
                ; go back to ABORT.
                
                lda.# es_refill1 
                jsr printstring
        
                jmp a_abort

quit_refill_ok
                ; Set >IN to zero (pointer to beginning of current input buffer)
                stz.d to-in

                ; HIER HIER HIER 
                ; TODO Interpret by calling REFILL
                
                ; Display system prompt if all went well
                pha
                lda.# s_ok
                jsr printstring
                pla
        

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; *** TESTING ***

                brk 00 ; BRK for 265sxb tests (drops back to Mensch Monitor)
;               stp    ; STP for crude65816 emulator tests

; *** TESTING ***
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

                bra quit_main_loop

z_cold
z_abort         
z_quit          nop  ; DUMMY, TODO figure out compilation goal
                

; -------------------------------------------------------------------
; ACCEPT ( addr n1 -- n2 ) X bytes / X cycles
; Receive a string of at most n1 characters, placing them at addr. Return the
; actual number of characters as n2. Characters are echoed as they are received

a_accept        
                ; TODO Testing version only: Echo characters to screen

        .a8
                jsr.l GET_CHR
                jsr.l PUT_CHR
                bra a_accept
                
z_accept        rts

; -------------------------------------------------------------------
; BYE ( -- ) 2 bytes / 7-8 cycles
; Leave Liara Forth, returning to Mensch Monitor

a_bye           brk 00  ; status byte 00 required for assembler
z_bye           rts     ; dummy for compiling, never reached

; -------------------------------------------------------------------
; CR ( -- ) X bytes / X cycles
; Cause following output to appear at beginning of next line

a_cr            
        .a8     
                lda.# AscLF     ; test with AscCR for emulators
                jsr.l PUT_CHR
        .a16

z_cr            rts

; -------------------------------------------------------------------
; DROP ( n -- ) 4 bytes / 9 cycles
; Drop first entry on Data Stack

a_drop          
                ldy.dx 00 
                inx
                inx

z_drop          rts


; -------------------------------------------------------------------
; DUP  ( n -- n n ) 4 bytes / 9 cycles
; Duplicate first entry on Data Stack

a_dup           dex
                dex
                sty.dx 00

z_dup           rts

; -------------------------------------------------------------------
; FALSE ( -- f ) 7 bytes / 12 cycles
; Pushes value $0000 for Forth true on Data Stack. This is the same code as for 
; ZERO, see there. Dictionary entry should have a_zero/z_zero instead of
; a_false/z_false

; -------------------------------------------------------------------
; HERE ( -- u ) 6 bytes / 13 cycles
; Push Compiler Pointer address on the Data Stack

a_here          dex
                dex
                sty.dx 00
                ldy.d cp

z_here          rts

; -------------------------------------------------------------------
; NIP ( n m -- m ) 2 bytes / 4 cycles
; Delete entry that is NOS
;
a_nip           inx
                inx
z_nip           rts

; -------------------------------------------------------------------
; 1 "ONE" ( -- 1 ) 7 bytes / 12 cycles
; Pushes the number 1 on the Data Stack

a_one           dex
                dex
                sty.dx 00
                ldy.# 0001 
   
z_one           rts

; -------------------------------------------------------------------
; 1+ "ONE-PLUS" ( n -- n+1 ) 1 bytes / 2 cycles
; Add 1 to TOS. Because there is no checking if there is actually anything on
; the Data Stack, this routine will fail silently if the stack is empty. 

a_one-plus      iny
z_one-plus      rts

; -------------------------------------------------------------------
; + "PLUS" ( n m -- n+m ) 7 bytes / X cycles
; Add TOS and NOS

a_plus          tya
                clc
                adc.dx 00
                tay
                inx
                inx 

z_plus          rts

; ------------------------------------------------------------------- 
; REFILL ( -- f ) X bytes / X cycles
; "Attempt to fill the input buffer from the input source, returning a true flag
; if successful. When the input source is the user input device, attempt to
; receive input into the terminal input buffer. If successful, make the result
; the input buffer, set >IN to zero, and return true. Receipt of a line
; containing no characters is considered successful. If there is no input
; available from the current input source, return false. When the input source
; is a string from EVALUATE, return false and perform no other action."
; See https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
; and Conklin & Rather p. 156
a_refill        
                ; Get input source from SOURCE-ID. We don't have blocks in this
                ; version, or else we would have to check BLK first. This is an
                ; optimized version of a subroutine jump to SOURCE-ID
                lda.d insrc
                bne refill_source_is_not_keyboard

                ; SOURCE-ID of zero means we're getting stuff from the keyboard
                ; with ACCEPT
                jsr a_accept

                ; TODO handle input buffer stuff
                
                ; Add success flag TRUE
                dex
                dex
                sty.dx 00
                ldy.# 0ffff
                rts

refill_source_is_not_keyboard
                ; If SOURCE-ID doesn't return a zero, it must be a string in
                ; memory or a file (remember, no blocks in this version)
                cmp.# 0ffff
                bne refill_source_not_string

                ; Simply return FALSE flag as per specification
                dex
                dex
                sty.dx 00
                ldy.# 0000
                rts

refill_source_is_not_string
                ; Since we don't have blocks, this must mean that we are trying
                ; to read from a file. However, we don't have files yet, so we 
                ; report an error and jump to ABORT.
                lda.# es_refill2 
                jsr printstring
                jmp a_abort

z_refill        rts     ; dummy for compiling

; -------------------------------------------------------------------
; SOURCE-ID ( -- n ) 6 bytes / 13 cycles
; Identify the input source unless it is a block (s. Conklin & Rather p. 156).
; Since we don't have blocks (yet), this will give the input source: 0 is
; keyboard, -1 (0ffff) is character string, and a text file gives the fileid.
a_source-id     dex
                dex
                sty.dx 00
                ldy.d insrc
                
z_source-id     rts

; -------------------------------------------------------------------
; STATE ( -- addr ) 7 bytes / 12 cycles
; Return the address of a cell containing the compilation-state flag. STATE
; is true when in compilation state, false otherwise. STATE should be changed
; directly by the user; see
; http://forth.sourceforge.net/standard/dpans/dpans6.htm#6.1.2250

a_state         dex
                dex
                sty.dx 00
                ldy.# state
                
z_state         rts


; -------------------------------------------------------------------
; SWAP ( n m -- m n ) 5 bytes / 12 cycles
; Exchange TOS with NOS, destroys Y

a_swap          lda.dx 00
                sty.dx 00
                tay 

z_swap          rts

; -------------------------------------------------------------------
; TRUE ( -- f ) 7 bytes / 12 cycles
; Pushes value $FFFF for Forth true on Data Stack

a_true          dex
                dex
                sty.dx 00 
                ldy.# 0ffff

z_true          rts

; -------------------------------------------------------------------
; TUCK ( n m -- m n m ) 8 bytes / 19 cycles
; Insert TOS below NOS

a_tuck          dex
                dex
                lda.dx 2
                sta.dx 0
                sty.dx 2
                
z_tuck          rts

; -------------------------------------------------------------------
; 0 "ZERO" ( -- 0 ) 7 bytes / 12 cycles
; Pushes the number 0000 on the Data Stack

a_zero          dex
                dex
                sty.dx 00 
                ldy.# 0000

z_zero          rts



; ===================================================================
; MIDDLE INCLUDES

        .include dict_headers.tasm

; ===================================================================
; LOW LEVEL HELPER FUNCTIONS

; ------------------------------------------------------------------- 
; Print a zero terminated string to the console, adding a CR character. Takes
; the address of the string in 16-bit A register, calls PUT_CHR from the Mensch
; Monitor. A is destroyed. We could probably figure out some way to use TYPE
; instead, but zero terminated strings are easier for the 65816 to use. 
; This would be shorter with PUT_STR, but we want to keep the number of Monitor
; routines called as small as possible to make porting the code easier
printstring     
                ; don't use tmpdsp for X because we don't know if the user has
                ; used it for something already
                phx
                tax ; x16 contains address of string
        .a8
@
                lda.x 0000      ; LDA $0000,X 
                beq printstring_done
                jsr.l PUT_CHR
                inx
                bra -

printstring_done
                lda.# AscLF     ; should be CR on some systems
                jsr.l PUT_CHR
        .a16
                plx
                rts

; -------------------------------------------------------------------
; Swap the two input buffers. Assumes A16, destroys A.
; TODO Rewrite
swapbuffers     
                lda.d cib
                eor.# 0100  ; flip 07d00 / 07c00
                sta.d cib
                rts

; -------------------------------------------------------------------
; Clear current buffer. Assumes buffer size 256 bytes and A16.
; Does not affect >IN (to-in). Remember Y is 16 bit at this point.
clearbuffer     
                sty.d tmptos
                lda.# 0000
                tay

@
                sta.diy cib     ; STA (cib),Y
                iny 
                iny
                cpy.# 0100
                bne -

                ldy.d tmptos
                rts


; ===================================================================
; BOTTOM INCLUDES

        .include strings.tasm

; ===================================================================
; TESTING ROUTINES (UNCOMMENT FOR USE)
                
                ; --- TODO TESTING ---
                ; lda.# 61
                ; jsr.l 00:e04b
                ; brk 00
                ; --- TODO TESTING ---


; ===================================================================
; END

        .end
