; Liara Forth for the W65C265SXB
; Scot W. Stevenson <scot.stevenson@gmail.com>
; First version: 01. Apr 2016
; This version: 26. Feb 2017

; This code is written in Typist's Assembler Notation for the 65c02/65816
; See docs/MANUAL.md for more information

        .mpu 65816
;       .origin 8000    ; start of code to save to Flash memory
        .origin 6000    ; start of code to save to built-in RAM

; ===================================================================
; TOP INCLUDES

        .include definitions.tasm

; Hardware dependencies are isolated to a large degree in kernel files. Liara
; Forth ships with two such files: One for the crude65816 emulator, and one for
; the 265sxb board. Only use one.

;       .include kernel_emu.tasm        ; routines for crude65815 emulator
        .include kernel_265sxb.tasm     ; routines for the W65C265SXB


; ===================================================================
; DICTIONARY ROUTINES

; Word code routines are sorted alphabetically, except for the first three
; - COLD, ABORT, and QUIT - and a few others that flow into each other. The
; byte and cycle values are calculated without the RTS instruction.


; -------------------------------------------------------------------
; COLD ( -- ) X bytes / X Cycles
; Reboot the system
xt_cold  

                jmp reset_hardware      ; don't use JSR, jump back to start
start           
        .!native        ; these should be handled by hardware reset
        .!a16
        .!xy16
                sei

                ; TODO switch to Single Task mode
                ; TODO set up Direct Page stuff
                ; TODO initiate User variables


                ; We start out in decimal mode
                jsr xt_decimal
                
                ; The name token (nt) of DROP is always the first one in the
                ; virgin Dictionary, so we start off the Dictionary Pointer (DP)
                ; there. Anything that comes after that (with WORDS, before
                ; that) is high-level
                lda.# nt_drop
                sta.d dp
                
                ; The compiler pointer (CP) points to the first free cell 
                ; in RAM
                lda.# cp0
                sta.d cp

                ; Prepare input buffers
                lda.# ibuffer1  ; start with first input buffer
                sta.d cib
                stz.d piblen    ; previous input buffer is empty
                stz.d insrc     ; SOURCE-ID is zero
                stz.d state     ; STATE is zero (interpret)
                
                ; Clear Data Stack
                ldy.# 0000
                ldx.# dsp0

                ; Clean the screen, assumes vt100 terminal
                jsr xt_page
                
                ; Define high-level words via EVALUATE. At this point, whatever
                ; is in Y (TOS) is garbage, so we don't have to push it to the 
                ; stack first
                dex
                dex
                dex
                dex
                lda.# hi-start  
                sta.dx 00                       ; Start address goes in NOS
                ldy.# { hi-end - hi-start }     ; length goes in TOS

                jsr xt_evaluate

                ; fall through to ABORT

; -------------------------------------------------------------------
; ABORT ( -- ) 8+ bytes / X cycles
; Reset the parameter (data) stack pointer and continue as QUIT 
; We can jump here via subroutine because we reset the stack pointer
; anyway. Flows into QUIT.
; TODO see which parts of COLD we should integrate here
xt_abort         
        .a16    
                ; clear Data Stack
                ldy.# 0000
                ldx.# dsp0


; drops through to QUIT, z_abort is the same as z_quit.

; -------------------------------------------------------------------
; QUIT ( -- ) X bytes / X cycles
; Reset the input, clearning Return Stack. Jumps to QUIT do not have to be
; subroutine jumps as the Return Stack is cleared anyway. Liara Forth follows
; the ANSI Forth recommendation to use REFILL. Note we don't display the "ok"
; system prompt until after the first output. This follows Gforth.
xt_quit          
                ; clear Return Stack
                lda.# stack0
                tcs

                ; make sure Instruction Pointer is empty
                ; TODO move this someplace else or else it will end up in ROM
                stz execute_ip

                ; switch SOURCE-ID to zero (keyboard input)
                stz.d insrc
                
                ; switch to interpret state (STATE is zero)
                stz.d state
               
quit_get_line
                ; Empty current input buffer. Note the previous input line is
                ; conserved even if we came here from an abort
                stz.d ciblen
               
                ; Accept a line from the current input source
                jsr xt_refill            ; ( -- f ) 
                
                tya                     ; force flag test
                bne quit_refill_successful

                ; If REFILL returned a FALSE flag, something went wrong and we
                ; need to print an error message and reset the machine. We don't
                ; need to save TOS because we're going to clobber it anyway when we
                ; go back to ABORT.
                lda.# es_refill1 
                jmp error 


quit_refill_successful
                ; Assume we have successfully accepted a string of input from
                ; a source, with address of buffer in cib and length of input in
                ; ciblen. We arrive here still with the TRUE flag from REFILL as
                ; TOS (in Y)
                ldy.dx 00       ; drop TOS
                inx
                inx
                
                ; make >IN point to begining of buffer
                stz.d toin
 
                ; Main compile/execute routine. Consider moving this inside QUIT
                ; once we know everything works 
                jsr interpret

                ; Test for Data Stack underflow. Our stack is so large in single
                ; user mode that we don't bother checking for overflow - if that
                ; happens, we're screwed anyway
                cpx.# { dsp0 + 1 }
                bcc quit_ok     ; DSP must always be smaller (!) than DSP0
                
                lda.# es_underflow
                jmp error

quit_ok
                ; Display system prompt if all went well. If we're interpreting,
                ; this is " ok", if we're compiling, it's " compiled"
                lda.d state
                bne quit_compiled

                lda.# s_ok
                bra quit_print
quit_compiled
                lda.# s_compiled        ; fall through to quit_print
quit_print
                jsr print_string

                ; Awesome line, everybody. Now get the next one
                jmp quit_get_line

z_cold
z_abort         
z_quit          nop  ; dummy for compilation, TODO test if required

; -------------------------------------------------------------------
; < "LESS" ( n m -- f ) X bytes / X cycles
; Return true flag if NOS < TOS. See
; http://www.6502.org/tutorials/compare_beyond.html for details on the
; comparisons
xt_less          
                tya
                ldy.# 0000      ; default is false

                sec 
                sbc.dx 00
                beq xt_less_nip      ; the same is not greater
                bvc xt_less_no_ov    ; no overflow, skip ahead

                ; Deal with oveflow because we use signed numbers
                eor.# 8000      ; compliment negative flag

xt_less_no_ov
                ; if we're negative TOS > NOS
                bmi xt_less_nip     
                dey             
xt_less_nip
                inx
                inx

z_less          rts


; -------------------------------------------------------------------
; <> "NOT-EQUAL" ( n m -- f ) X bytes / X cycles
; Return true flag if TOS and NOS are not the same. This is just a different
; version of EQUAL, we repeat the code for speed reasons
xt_not-equal     
                tya
                ldy.# 0000      ; default value is false

                cmp.dx 00
                beq not-equal_equal 
                dey             ; wraps to 0FFFF (true) 

not-equal_equal                 ; yes, this is a silly name
                inx
                inx
     
z_not-equal     rts


; -------------------------------------------------------------------
; <# "LESSNUMBER" ( -- ) 8 bytes / X cycles
; Start the process to create pictured numeric output. The new string is
; constructed from back to front, saving the new character at the beginning of
; the output string. Since we use PAD as a starting address and work backward
; (!), the string is constructed in the space between the end of the dictionary
; (as defined by CP) and the PAD. This allows us to satisfy the ANS Forth
; condition that programs don't fool around with the PAD but still use its
; address. Code based on pForth, see
; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth pForth is in the pubic
; domain. Forth is : <# PAD HLD ! ; we use the internal variable tohold instead
; of HLD.
xt_lessnumber    
                jsr xt_pad
                sty.d tohold
                ldy.dx 00
                inx
                inx
   
z_lessnumber    rts


; -------------------------------------------------------------------
; > "GREATER" ( n m -- f ) X bytes / X cycles
; Return true flag if NOS > TOS. See
; http://www.6502.org/tutorials/compare_beyond.html for details on the
; comparisons
xt_greater       
                tya
                ldy.# 0000      ; default is false

                sec 
                sbc.dx 00
                beq xt_greater_nip      ; the same is not greater
                bvc xt_greater_no_ov    ; no overflow, skip ahead

                ; Deal with oveflow because we use signed numbers
                eor.# 8000      ; compliment negative flag

xt_greater_no_ov
                ; if we're still positiv, TOS < NOS
                bpl xt_greater_nip     
                dey             
xt_greater_nip
                inx
                inx

z_greater       rts


; -------------------------------------------------------------------
; >BODY "TOBODY" ( xt -- addr ) 3 bytes / 6 cycles
; Given a word's execution token (xt), return the address of the start of that
; word's parameter field (PFA). This is the address that HERE would return right
; after CREATE
xt_tobody        
                ; In the header, xt already points to the CFA, which CREATE by
                ; default fills with a JSR to DOVAR. We just need to move xt
                ; down by three bytes
                iny
                iny
                iny

z_tobody        rts

; -------------------------------------------------------------------
; >IN "TOIN" ( -- addr ) 6 bytes / 12 cycles
; Return address where pointer to current char in input buffer lives (>IN)
xt_to-in         
                dex
                dex
                sty.dx 00

                ldy.# toin      ; >IN
z_to-in         rts

; -------------------------------------------------------------------
; >NUMBER ( ud addr u -- ud addr u ) X bytes / X cycles
; Convert a string to a double number. Logic here is based on the routine by
; Phil Burk of the same name in pForth; see
; https://github.com/philburk/pforth/blob/master/fth/numberio.fth the origional
; Forth code. We arrive here from NUMBER which has made sure that we don't have
; to deal with a sign and we don't have to deal with a dot as a last character
; that signalizes double - this should be a pure number string.
; This routine calles UM*, which uses tmp1, tmp2 and tmp3, so we cannot access
; any of those.
xt_tonumber      
        .!a16
                ; For the math routine, we move the inputs to the scratchpad to
                ; avoid having to fool around with the Data Stack. 
                ;
                ;     +-----+-----+-----+-----+-----+-----+-----+-----+
                ;     |   UD-LO   |   UD-HI   |     N     | UD-HI-LO  |
                ;     |           |           |           |           |
                ;     |  S    S+1 | S+2   S+3 | S+4   S+5 | S+6   S+7 |
                ;     +-----+-----+-----+-----+-----+-----+-----+-----+
                
                ; The math routine works by converting one character to its
                ; numerical value (N) via DIGIT? and storing it in S+4 for
                ; the moment. We then multiply the UD-HI value with the radix
                ; (from BASE) using UM*, which returns a double-cell result. We
                ; discard the high cell of that result (UD-HI-HI) and store the
                ; low cell (UD-HI-LO) in S+6 for now. -- The second part is
                ; multiplying UD-LO with the radix. The high cell (UD-LO-HI)
                ; gets put in S+2, the low cell (HD-LO-LO) in S. We then use
                ; a version of D+ to add ( S S+2 ) and ( S+4 S+6) together,
                ; storing the result back in S and S+2, before we start another
                ; round with it as the new UD-LO and UD-HI.

                ; Fill the scratchpad. We arrive with ( ud-lo ud-hi addr u ).
                ; After this step, the original ud-lo and ud-hi will still be on
                ; the Data Stack, but will be ignored and later overwritten
                lda.dx 04               ; ud-lo
                sta.d scratch 
                lda.dx 02               ; ud-hi
                sta.d { scratch + 2 } 

                ; We push down one on the Data Stack to use TOS for character
                ; conversion - now ( ud-lo ud-hi addr u u ) 
                dex
                dex
                sty.dx 00

tonumber_loop
                ; Get one character
                lda.dxi 02       
                tay             ; ( ud-lo ud-hi addr u char ) 

                ; Convert one character. DIGIT? takes care of the correct
                ; register size for A and does a paranoid AND to make sure that
                ; B is zero, so we don't have to do any of that here. 
                jsr xt_digitq   ; ( char -- n -1 | char 0 ) 
                
                ; This gives us (ud-lo ud-hi addr u char f | n f ), so check the
                ; flag. If it is zero, we return what we have and let the caller
                ; (usually NUMBER) complain to the user
                tya             
                bne tonumber_ok

                ldy.dx 00
                inx
                inx
                bra tonumber_done

tonumber_ok
                ; Conversion was successful, so we're here with 
                ; ( ud-lo ud-hi addr u n -1 ) and can start the math routine.
                
                ; Save N so we don't have to fool around with the Data Stack
                lda.dx 00
                sta.d { scratch + 4 }

                ; Now multiply ud-hi (the one in the scratchpad, not the
                ; original one in the Data Stack) by the radix from BASE. We can
                ; clobber TOS and NOS
                lda.d  { scratch + 2 }  
                sta.dx 00
                ldy.d base              ; ( ud-lo ud-hi addr u ud-hi base )

                ; UM* returns a double celled number
                jsr xt_umstar   ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi ) 

                ; Move ud-hi-lo to safety
                lda.dx 00               ; ud-hi-lo
                sta.d { scratch + 6 } 

                ; Now we multiply ud-lo, overwriting the stack entries
                lda.d scratch
                sta.dx 00               ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
                ldy.d base              ; ( ud-lo ud-hi addr u ud-lo base )

                jsr xt_umstar   ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi ) 
                sty.d { scratch + 2 }
                lda.dx 00
                sta.d scratch

                ; This is a faster version of D+
                lda.d scratch
                clc
                adc.d { scratch + 4 }
                sta.d scratch           ; this is the new ud-lo
                lda.d { scratch + 2 }
                adc.d { scratch + 6 }
                sta.d { scratch + 2 }   ; this is the new ud-hi

                ; Clean up: Get rid of one of the two top elements on the Data
                ; Stack. NIP is faster if Y is TOS
                inx
                inx             ; ( ud-lo ud-hi addr u ud-lo-hi ) 

                ; One character down
                inc.dx 02               ; increase address
                dec.dx 00               ; decrease length

                bne tonumber_loop

tonumber_done
                ; Counter has reached zero or we have an error. In both cases,
                ; we clean up the Data Stack and return. We arrive here with
                ; ( ud-lo ud-hi addr u char ) if there was an error
                ; and ( ud-lo ud-hi addr u ud-lo ) if not
	        ldy.dx 00
                inx
                inx             ; ( ud-lo ud-hi addr u ) 

                ; The new ud-lo and ud-hi are still on the scratch pad
                lda.d scratch   ; new ud-lo
                sta.dx 04
                lda.d { scratch + 2 }
                sta.dx 02       ; new ud-hi
	
z_tonumber      rts


; -------------------------------------------------------------------
; >R "TOR" ( n -- ) (R: -- n )  7 bytes / 22 cycles
; Move Top of Data Stack to Top of Return Stack
; TODO consider stripping PHA/PLA if natively compiled (see COMPILE,)
xt_tor           
        .!a16                
                ; Save the return address. If this word is natively coded, this
                ; is a complete waste of nine cycles, but required for
                ; subroutine coding
                pla

                phy             ; the actual work

                ldy.dx 00       ; DROP
                inx
                inx

                pha             ; put return address back in place

z_tor           rts


; -------------------------------------------------------------------
; . "DOT" ( n -- ) X bytes / X cycles
; Print value that is TOS followed by a single space. Forth code is  
; DUP ABS 0 <# #S ROT SIGN #> TYPE SPACE  Based on 
; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
; Since this is used interactively, and humans are slow (just ask GlaDOS), we
; focus on size.
; TODO Once we know this works, move to assembler
xt_dot           
                jsr xt_dup              ; ( n n ) 
                jsr xt_abs              ; ( n n ) 
                jsr xt_zero             ; ( n n 0 ) 
                jsr xt_lessnumber       ; ( n n 0 ) 
                jsr xt_hashs            ; ( n ud ) 
                jsr xt_rot              ; ( ud n ) 
                jsr xt_sign             ; ( ud ) 
                jsr xt_numbermore       
                jsr xt_type
                jsr xt_space

z_dot           rts

; -------------------------------------------------------------------
; .( "DOTPAREN" ( "string" -- ) 13 bytes / X cycles
; Display string delimited by ")" immediately, regardless if word is compiled or
; interpreted. Forth definition is  .( [CHAR] ) PARSE TYPE ; IMMEDIATE
; TODO Decide if this should be a high-level word
xt_dotparen     
               ; use PARSE to find the end of the string
               dex
               dex
               sty.dx 00
               ldy.# ')'

               jsr xt_parse      ; ( -- addr u) 
               jsr xt_type

z_dotparen     rts


; -------------------------------------------------------------------
; ." "DOTQUOTE" ( -- ) X bytes / X cycles
; Compile string that is printed during run time. ANSI Forth wants this to be
; compile-only, even though everybody and their friend uses it for everything.
; We follow the book here, and recommend .( for general printing. 
xt_dotquote      
                dex
                dex
                sty.dx 00
                ldy.# 0022              ; ASCII for "

                jsr xt_parse
                jsr xt_sliteral

                phe.# xt_type
                jsr cmpl_subroutine     

                rts
z_dotquote      


; -------------------------------------------------------------------
; .S "DOTS" ( -- ) X bytes / X cycles
; Print content of Data Stack non-distructively. Since this is for humans, we
; don't have to worry about speed. We follow the format of Gforth
; and print the number of elements first in brackets, followed by the Data Stack
; content (if present).
xt_dots          
        .!a16
        .!xy16
                jsr xt_depth             ; ( -- u)

                ; Print stack depth in brackets
                ; TODO rewrite this to use EMIT
                lda.# '<'
                jsr put_chr

                ; --- TEMP print routine ---
                tya
                and.# 0ff00
                xba 
                jsr byte_to_ascii
                tya
                and.# 00ff
                jsr byte_to_ascii
                ; --- TEMP print routine ---

                ; TODO rewrite this to use EMIT
                lda.# '>'
                jsr put_chr
                jsr xt_space


                ; There will be a lot of cases where .S is used when the stack
                ; is empty. Get them first and exit quickly
                tya                     ; force flag test
                beq dots_done

dots_not_empty
                ; We have at least one element on the stack, which used to be in
                ; Y as TOS, but is now NOS and therefore accessable by X. Also,
                ; the depth of the Data Stack is already in Y waiting to be used
                ; as a counter. We use this to our advantage. 
                
                ; Normally we would go with STX.D tmptos / LDX.D tmptos with
                ; 4 bytes and 8 cycles because we value speed over size.
                ; However, .S is used interactively, and humans
                ; won't notice the one cycle more of PHX/PLX (2 bytes,
                ; 9 cycles), and we save the two bytes.
                phx

                ; We print from the bottom up. Note that the Data Stack locations
                ; dsp0 and dsp0+2 always contain garbage so they can be skipped.
                ; See docs/INTERNALS.md for details 
                ldx.# dsp0      ; points to dsp0, which is garbage
                dex
                dex             ; points to dsp0-2, which is also garbage
                
dots_loop
                dex             ; get next element on DS, initially dsp0-4
                dex             

                ; --- TEMP print routine ---
                ; TODO call EMIT
                lda.dx 00
                and.# 0ff00
                xba 
                jsr byte_to_ascii
                lda.dx 00
                and.# 00ff
                jsr byte_to_ascii
                jsr xt_space
                ; --- TEMP print routine ---

                dey
                bne dots_loop

                plx             ; restore original DSP

dots_done
                ; Clean up. Again, we don't care about speed in this
                ; word so we save one byte by doing DROP the slow way
                jsr xt_drop

z_dots          rts


; -------------------------------------------------------------------
; , "COMMA" ( n -- ) 11 bytes / 29 cycles
; Allot one cell and store TOS in memory. We ignore alignment issues, though
; satisfy the ANSI requirement that an aligned compiler pointer will remain
; aligned
; There is another variant possible: 
;               tya
;               ldy.d cp
;               sta.y 0000
;               iny
;               iny
;               sty.d cp
;               ldy.dx 00
;               inx
;               inx
; This is as fast as the variant below, but three bytes longer
xt_comma         
        .!a16
                tya
                sta.di cp       ; STA (CP)
                inc.d cp
                inc.d cp

                ldy.dx 00
                inx
                inx

z_comma         rts


; -------------------------------------------------------------------
; : "COLON" ( "name" -- ) X bytes / X cycles
; Start compilation of new word into the Dictionary. Use the CREATE routine 
; and fill in the rest by hand.
xt_colon         
        .!a16
                ; if we are already in compile mode, complain and abort
                lda.d state
                beq +

                lda.# es_state
                jmp error
@
                ; Switch to compile state. From now on, everything goes in the
                ; Dictionary
                inc.d state

                ; CREATE is going to change DP to point to the new word's
                ; header. While this is fine for (say) variables, it would mean
                ; that FIND-NAME etc would find a half-finished word when
                ; looking in the Dictionary. To prevent this, we save the old
                ; version of DP and restore it later. The new DP is placed in
                ; the variable WORKWORD until we're finished with a SEMICOLON.
                lda.d dp
                pha             ; CREATE uses tmp1, tmp2 and tmp3

                jsr xt_create

                ; Get the nt of the new word as described above. Only COLON,
                ; SEMICOLON and RECURSE access WORKWORD
                lda.d dp
                sta.d workword
                pla
                sta.d dp 

                ; CREATE includes a subroutine jump to DOVAR by default. We back
                ; up three bytes and overwrite that. Note that 3 x DEC.D would
                ; use 3 bytes and 18 cycles; this version uses 8 bytes but
                ; only 13 cycles
                lda.d cp
                sec
                sbc.# 0003
                sta.d cp

z_colon         rts


; -------------------------------------------------------------------
; ; "SEMICOLON" ( -- ) X bytes / X cycles
; End the compilation of a new word into the Dictionary. When we enter this, 
; WORKWORD is pointing to the nt_ of this word in the Dictionary, DP to the
; previous word, and CP to the next free byte.  A Forth definition would be 
; (see "Starting Forth"):
;  : ;  POSTPONE EXIT  REVEAL POSTPONE ; [ ; IMMEDIATE
xt_semicolon     
        .!a16
                sty.d tmptos

                ; CP is the byte that will be the address we use in the header for
                ; the end-of-compile address (z_word). This is six bytes down in
                ; the header
                ldy.# 0006
                lda.d cp
                sta.diy workword        ; STA (WORKWORD),Y

                ; Add the RTS instruction to the end of the current word. We
                ; don't have to switch the size of the A register because we
                ; only move up the CP by one and the MSB will be overwritten. 
                ; Little endian MPUs for the win!
                lda.# 60                ; opcode for RTS
                sta.di cp               ; STA (CP)
                inc.d cp                ; MSB will be overwritten
                
                ; Word definition is complete. Make the new word the last one in
                ; the Dictionary
                lda.d workword
                sta.d dp

                ; Get our TOS back
                ldy.d tmptos
                
                ; Set compile flag back to zero so we're back in interpret mode
                stz.d state
                
z_semicolon     rts


; -------------------------------------------------------------------
; # "HASH" / "NUMBER-SIGN" ( ud -- ud )  X bytes / X cycles
; Add one character to the beginning of the pictured output string.
; Code based on https://github.com/philburk/pforth/blob/master/fth/numberio.fth
; Forth code is  BASE @ UD/MOD ROT 9 OVER < IF 7 + THEN [CHAR] 0 + HOLD ;
; TODO convert more parts to assembler
xt_hash          
        .!a16
                jsr xt_base     ; ( ud addr ) 
                jsr xt_fetch    ; ( ud u )  
                jsr xt_udmod    ; ( rem ud )
                jsr xt_rot      ; ( ud rem ) 
 
                ; Convert the number that is left over to an ASCII character. We
                ; use a string lookup for speed
        .a8
                lda.y alphastring
        .a16
                ; overwrite remainder with ASCII value
                and.# 00ff
                tay             ; ( ud char ) 

                jsr xt_hold     ; JSR/RTS
                
z_hash          rts 


; -------------------------------------------------------------------
; #> "NUMBERMORE" / "NUMBER-GREATER" ( d -- addr u ) X bytes / X cycles
; Finish conversion of pictured number string, putting address and length on the 
; Data Stack. Original Fort is  2DROP HLD @ PAD OVER -  Based on
; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
xt_numbermore    
        .!a16
                ; We simply overwrite the double cell number, saving us a lot of
                ; stack thrashing. First, put the address of the string's head in
                ; TOS and NOS
                ldy.d tohold
                sty.dx 00       ; ( addr addr ) 

                ; add the address of the string's end, which is PAD
                jsr xt_pad      ; ( addr addr pad ) 

                sec
                tya
                sbc.dx 00       ; pad - addr is the length of the string
                tay             ; ( addr addr n ) 

                inx             ; NIP
                inx

z_numbermore    rts


; -------------------------------------------------------------------
; #S "HASHS" / "NUMBER SIGN" ( ud -- ud ) X bytes / X cycles
; Completely convert number for pictured numerical output. Based on
; https://github.com/philburk/pforth/blob/master/fth/system.fth
; Original Forth code  BEGIN # 2DUP OR 0= UNTIL
xt_hashs         
        .!a16
hashs_loop
                ; covert a single number ("#")
                jsr xt_hash     ; ( ud -- ud ) 

                ; stop when the double-celled number on the TOS is zero
                tya
                ora.dx 00
                bne hashs_loop 
                
z_hashs         rts

; -------------------------------------------------------------------
; ? "QUESTION" ( addr -- ) X bytes / X cycles
; Print content of a variable. This is used interactively and humans are
; slow, so we just go for the subroutine jumps to keep it short
xt_question      
                jsr xt_fetch
                jsr xt_dot

z_question      rts


; -------------------------------------------------------------------
; QDUP ( n -- 0 | n n ) X bytes / X cycles
; If top element on Data Stack is not zero, duplicate it
xt_qdup          
                tya
                beq z_qdup

                dex
                dex
                sty.dx 00

z_qdup          rts


; -------------------------------------------------------------------
; ! "STORE" ( n addr -- ) 9 bytes / X cycles
; Save value at designated memory location
xt_store         
        .!a16
                lda.dx 00       ; NOS has value
                sta.y 0000

                ldy.dx 02
                inx
                inx
                inx
                inx

z_store         rts


; -------------------------------------------------------------------
; @ "FETCH" ( addr -- n ) 4 bytes / 7-8 cycles
; Get one cell (16 bit) value from given address
xt_fetch         
                lda.y 0000
                tay

z_fetch         rts


; -------------------------------------------------------------------
; ['] "BRACKET-TICK" ( -- ) X bytes / X cycles
; Store xt of following word during compilation
xt_brackettick   
                jsr xt_tick
                jmp xt_literal  ; JSR/RTS
z_brackettick   


; -------------------------------------------------------------------
; [ "LEFTBRACKET" ( -- ) X bytes / X cycles
; Enter the interpretation state. This is an immediate, compile-only word
xt_leftbracket   
                stz.d state
z_leftbracket   rts


; -------------------------------------------------------------------
; ] "RIGHTBRACKET" ( -- ) X bytes / X cycles
; Enter the compile state. In theory, we should be able to get away with
; a simple INC.A, but this is more error tolerant. For obvious reasons, this
; cannot be COMPILE-ONLY, and native compile doesn't make much sense either
xt_rightbracket  
                lda.# 0001
                sta.d state
                
z_rightbracket  rts

; -------------------------------------------------------------------
; [CHAR] "BRACKET-CHAR" ( "c" -- ) X bytes / X cycles
; At compile time, compile the ASCII value of a character as a literal
; This is an immediate, compile-only word. A definition given in 
; http://forth-standard.org/standard/implement is 
; : [CHAR] CHAR POSTPONE LITERAL ; IMMEDIATE
; TODO decide if this is worth unrolling
xt_bracketchar  
                jsr xt_char
                jsr xt_literal
             
z_bracketchar  rts


; -------------------------------------------------------------------
; \ "BACKSLASH" ( -- ) 4 bytes / X cycles
; Ignore rest of line as comment
xt_backslash     
        .!a16
                ; Advance >IN to end of the line 
                lda.d ciblen
                sta.d toin

z_backslash     rts


; -------------------------------------------------------------------
; + "PLUS" ( n m -- n+m ) 7 bytes / X cycles
; Add TOS and NOS
xt_plus          
        .!a16
                tya
                clc
                adc.dx 00
                tay
                inx
                inx 

z_plus          rts


; -------------------------------------------------------------------
; - "MINUS" ( n m -- n-m ) 10 bytes / X cycles
; Subtract NOS from TOS
xt_minus         
        .!a16
                tya
                eor.# 0ffff

                sec             ; not CLC
                adc.dx 00 

                tay
                inx
                inx
                
z_minus         rts

; -------------------------------------------------------------------
; -ROT ( a b c -- c a b )  X bytes / X cycles
; Rotate top three entries of Data Stack upwards
xt_mrot          
        .!a16
        .!xy16
                lda.dx 02       ; save a
                sty.dx 02       ; move c to 3OS
                ldy.dx 00       ; move b to TOS
                sta.dx 00       ; save a as NOS
             
z_mrot          rts


; -------------------------------------------------------------------
; = "EQUAL" ( n m -- f ) 11 bytes / 18-20 cycles
; See if TOS and NOS are the same
xt_equal         
                tya
                ldy.# 0000      ; default value is false

                cmp.dx 00
                bne equal_not
                dey             ; wraps to 0FFFF (true) 

equal_not
                inx
                inx

z_equal         rts


; -------------------------------------------------------------------
; 0 "ZERO" ( -- 0 ) 7 bytes / 12 cycles
; Pushes the number 0000 on the Data Stack
xt_zero          
        .!xy16
                dex
                dex
                sty.dx 00 
                ldy.# 0000

z_zero          rts
               
; -------------------------------------------------------------------
; 0= "ZERO-EQUAL" ( n -- f ) X bytes / X cycles
; Return the true flag if TOS is zero
xt_zero-equal    
        .!a16
                tya             ; force flag check
                bne ze_not_zero

                ldy.# 0ffff
                bra z_zero-equal
ze_not_zero     
                ldy.# 0000

z_zero-equal    rts


; -------------------------------------------------------------------
; 0< "ZERO-LESS" ( n -- f ) 11 bytes / X cycles
; Return the true flag if TOS is less than zero
xt_zero-less     
	.!a16
                tya	; force flag check
		bmi zero-less-is-less

                ldy.# 0000
                bra z_zero-less

zero-less-is-less
                ldy.# 0ffff

z_zero-less     rts

; -------------------------------------------------------------------
; 0<> "ZERO-NOTEQUAL" ( n -- f ) 11 bytes / X cycles
; Return the true flag if TOS is not zero
xt_zero-notequal
	.!a16
		tya     ; force flag check
                beq zne_is_zero
                ldy.# 0ffff
                bra z_zero-notequal
zne_is_zero
                ldy.# 0000
z_zero-notequal
                rts


; -------------------------------------------------------------------
; 0> "ZERO-MORE" ( n -- f ) X bytes / X cycles
; Return the true flag if TOS is more than zero
xt_zero-more     
        .!a16
                lda.# 0000              ; default is false

                dey
                bpl zero-more_true      ; was at least 1

                bra zero-more_done      ; nope, stays false

zero-more_true
                dec.a   ; wraps to 0ffff, true
zero-more_done
                tay

z_zero-more     rts


; -------------------------------------------------------------------
; 0BRANCH ( 0 | f -- ) X bytes / X cycles
; Branch if TOS is zero. This exects the next two bytes to be the address of
; where to branch to if the test fails. The code may not be natively compiled
; because we need the return address provided by JSR's push to the Return Stack
; This routine uses tmp1
xt_zbranch       
        .!a16
                ; encode subroutine jump to run time code 
                phe.# zbranch_rt
                jsr cmpl_subroutine

z_zbranch       rts

zbranch_rt
                ; Compiled component. Use the address on the Return Stack to
                ; decide where we want to return to
                pla
                sta.d tmp1

                ; See if the flag is zero, which is the whole purpose of this
                ; operation after all
                tya                ; force flag check
                beq zb_zero        ; flag is false (zero), so we branch

                ; Flag is TRUE, so we skip over the next two bytes. Put
                ; differently, this is the part between IF and THEN
                lda.d tmp1
                inc.a
                inc.a

                bra zb_done

zb_zero
                ; Flag is FALSE, so we take the dump to the address given in the
                ; next two bytes. We don't need Y anymore, so we can use it for
                ; indexing
                ldy.# 0001
                lda.diy tmp1

                ; Subtract one from the address given becasue of the RTS
                ; mechanics
                dec.a

zb_done
                ; One we or another, this is where we're going to jump to
                pha

                ; Clean up the Data Stack and jump
                ldy.dx 00
                inx
                inx

                rts

; -------------------------------------------------------------------
; 1 "ONE" ( -- 1 ) 7 bytes / 12 cycles
; Pushes the number 1 on the Data Stack
xt_one  
        .!xy16
                dex
                dex
                sty.dx 00
                ldy.# 0001 
   
z_one           rts


; -------------------------------------------------------------------
; 1- "ONE-MINUS" ( n -- n-1 ) 1 byte / 2 cycles
; Subtract 1 from Top of Stack (TOS). Because there is no checking if there is
; actually anything on the Data Stack, this routine will fail silently if the
; stack is empty
xt_one-minus      
        .!xy16
                dey
z_one-minus     rts


; -------------------------------------------------------------------
; 1+ "ONE-PLUS" ( n -- n+1 ) 1 byte / 2 cycles
; Add 1 to TOS. Because there is no checking if there is actually anything on
; the Data Stack, this routine will fail silently if the stack is empty
xt_one-plus      
        .!xy16
                iny
z_one-plus      rts


; -------------------------------------------------------------------
; 2 "TWO" ( -- 2 ) 7 bytes / 12 cycles
; Pushes the number 2 on the Data Stack
xt_two           
        .!xy16
                dex
                dex
                sty.dx 00
                ldy.# 0002 
   
z_two           rts


; -------------------------------------------------------------------
; 2* "TWO-STAR" ( n -- 2*n ) 3 bytes / 6 cycles
; Multiply Top of Stack (TOS) by 2. This is also used by CELLS
xt_two-star      
        .!a16
        .!xy16
                tya
                asl.a
                tay
                
z_two-star      rts


; -------------------------------------------------------------------
; 2DROP ( n m -- ) 6 bytes / 13 cycles
; Drop first two entries of Data Stack
xt_2drop         
                ldy.dx 02
                inx
                inx
                inx
                inx

z_2drop         rts


; -------------------------------------------------------------------
; 2DUP ( n m -- n m n m ) 10 bytes / 23 cycles
; Duplicated the top two data stack entries

xt_2dup          
        .!xy16
                dex
                dex
                dex
                dex
                sty.dx 02
                lda.dx 04
                sta.dx 00

z_2dup          rts


; -------------------------------------------------------------------
; ' "TICK" ( "string" -- xt ) X bytes / X cycles
; Given a string with the name of a word, return the word's execution token (xt)
; Abort if not found
xt_tick          
                jsr xt_parse-name       ; ( -- addr u ) 

                ; if we got a zero, complain and abort
                tya                     ; force flag check
                bne tick_have_word

                lda.# es_noname
                jmp error

tick_have_word
                jsr xt_find-name        ; ( addr u -- nt)
                tya                     ; force flag check

                ; if we didn't find string in the dictionary, complain and abort
                bne tick_have_nt

                lda.# es_syntax
                jmp error
                
tick_have_nt
                jsr xt_name-int            ; ( nt -- xt ) 
                
z_tick          rts

; -------------------------------------------------------------------
; ABORT" "ABORTQ" ( "string" -- ) X bytes / X cycles
; If flag on TOS is not false, print error message and abort. This a compile-only word
xt_abortq        
                jsr xt_squote           ; save string

                phe.# abortq_rt         ; compile run-time aspect
                jsr cmpl_subroutine

                rts

abortq_rt
                ; we land here with ( f addr u ) 
                lda.dx 02               ; get 3OS
                beq abortq_done          ; if FALSE, we're done

                ; nope, we print string and ABORT
                jsr xt_type
                jmp xt_abort            ; not JSR because we never come back
                
abortq_done
                ; drop the three entries from the Data Stack
                ldy.dx 04               ; fourth on the stack
                
                ; this is the same size, but three cycles faster than six INX
                ; instructions
                txa
                sec
                sbc.# 0006
                tax
                
z_abortq        rts


; -------------------------------------------------------------------
; ABS ( n -- u ) 8 bytes / X cycles
; Return the absolute value of a single number
xt_abs           
        .!a16
        .!xy16
                tya             ; force flag test
                bpl z_abs       ; positive number is easy

                ; negative: Calculate 0-n
                eor.# 0ffff 
                inc.a
                tay
                
z_abs           rts

; -------------------------------------------------------------------
; ACCEPT ( addr n1 -- n2 ) X bytes / X cycles
; Receive a string of at most n1 characters, placing them at addr. Return the
; actual number of characters as n2. Characters are echoed as they are received.
; ACCEPT is called by REFILL these days. 
xt_accept        
                ; Set up loop
                tya             ; force flag test
                bne accept_nonzero
                                
                ; if we were told to get zero chars, just quit
                inx             ; NIP, TOS is zero which is also FALSE
                inx

                rts

accept_nonzero
                lda.dx 00       ; address of buffer is NOS
                sta.d tmp1
                inx             ; NIP 
                inx

                sty.d tmp2      ; Save max number of chars in tmp2
                ldy.# 0000      ; Use Y as counter
        .a8

accept_loop
                ; TODO rewrite with KEY so we can revector it
                ; We don't need to check for CTRL-l, because a vt100 terminal
                ; clears the screen automatically
                jsr get_chr
       .!a8 
                ; we quit on both line feed and carriage return
                cmp.# AscLF     
                beq accept_eol
                cmp.# AscCR
                beq accept_eol

                ; BS and DEL do the same thing for the moment
                cmp.# AscBS     
                beq accept_bs
                cmp.# AscDEL
                beq accept_bs
  
                ; CTRL-c and ESC abort (see if this is too harsh)
                cmp.# AscCC     
                bne + 
                jmp xt_abort
@
                cmp.# AscESC
                bne + 
                jmp xt_abort
@
                ; CTRL-p will be used for "previous cmd", TODO
                cmp.# AscCP     
                bne +
        .a16
                lda.# tests_prev_cmd
                jsr print_string
        .a8
                bra accept_loop
@
                ; CTRL-n will be used for "next cmd", TODO 
                cmp.# AscCN
                bne +
        .a16
                lda.# tests_next_cmd
                jsr print_string
        .a8
                bra accept_loop

@
                ; That's quite enough, echo character
                ; TODO change to EMIT 
                jsr put_chr     ; echo character
        .!a8
                ; TODO multitasking: Add PAUSE here (or in EMIT)

                sta.diy cib     ; STA (CIB),Y
                iny
                cpy.d tmp2      ; reached character limit?
                bne accept_loop ; fall thru if buffer limit reached

accept_eol
                sty.d ciblen    ; Y contains number of chars accepted already
        .a16
                jsr xt_space     ; print final space
                rts             ; this is the actual return of the routine

accept_bs
        .!a8
                cpy.# 0000      ; buffer empty?
                bne +

                lda.# AscBELL   ; complain and don't delete beyond the start of line
                jsr put_chr
                iny
@
                dey
                lda.# AscBS     ; move back one
                jsr put_chr    
                lda.# AscSP     ; print a space (rubout) 
                jsr put_chr
                lda.# AscBS     ; move back over space
                jsr put_chr

                bra accept_loop

z_accept        rts

; -------------------------------------------------------------------
; AGAIN ( addr -- ) 22 bytes / 50 cycles
; Code a backwards branch to an address usually left by BEGIN. We use JMP
; instead of BRA to make sure we have the range.
; TODO see if we should insert a KEY? to make sure we can abort and/or a PAUSE
xt_again         

                ; Add the opcode for a JMP 
        .a8
                lda.# 4c
                sta.di cp       ; STA (CP)
        .a16
                inc.d cp        

                ; Add the address which should be TOS
                tya
                sta.di cp
                inc.d cp
                inc.d cp

                ; drop the address
                ldy.dx 00
                inx
                inx

z_again         rts


; -------------------------------------------------------------------
; ALLOT ( n -- ) X bytes / X cycles
; Reserve a certain number of bytes (not cells) or release them. If n = 0, do
; nothing. If n is negative, release n bytes, but only to the beginning of the
; Dictionary. If n is positive (the most common case), reserve n bytes, but not
; past the Dictionary.
; See http://forth-standard.org/standard/core/ALLOT
; TODO test negative values
xt_allot         
        .!a16
                tya                     ; force flag check
                beq allot_real_gone     ; zero bytes, don't do anything 
                bmi allot_minus         ; free memory instead of reserving it

                ; most common case: reserve n bytes. We've already transfered
                ; TOS to A, so we just have to add the current compile pointer
                clc
                adc.d cp                ; create new CP
                bcs allot_error         ; oops, we've wrapped

                tay                     ; save copy of new CP

                sec
                sbc.# maxram-single     
                bmi allot_done          ; oops, fall thru if beyond max RAM

allot_error
                lda.# es_allot
                jmp error

allot_minus
                ; negative value means we're freeing memory 
                sec
                sbc.d cp
                bcc allot_error         ; oops, we've wrapped

                tay

                sbc.# cp0               ; Carry Flag must still be set
                bmi allot_error         ; oops, gone too far back
                
                ; fall through to allot_done
allot_done      
                sty.d cp        ; new compiler pointer
allot_real_gone
                ldy.dx 00       ; DROP
                inx
                inx

z_allot         rts

; -------------------------------------------------------------------
; AND ( n m -- n ) 6 bytes / X cycles
; Logical AND
xt_and           
                tya
                and.dx 00
                tay

                inx     ; NIP
                inx

z_and           rts

; -------------------------------------------------------------------
; BASE ( -- addr ) X bytes / X cycles
; Get the address of where the radix for number conversion is stored
xt_base          
                dex
                dex
                sty.dx 00 

                ldy.# base

z_base          rts

; -------------------------------------------------------------------
; BELL ( -- ) X bytes / X cycles
; Trigger terminal bell on vt100 terminals
; TODO replace with EMIT
xt_bell          
        .!a16
                lda.# AscBELL 
                jsr put_chr

z_bell          rts

; -------------------------------------------------------------------
; BEGIN ( -- addr ) 6 bytes / 13 cycles
; Mark entry point for a loop. This is just an immediate version of here which
; could just as welle be coded as  : BEGIN HERE ; IMMEDIATE  but we code it here
; differently for speed
xt_begin         
                ; really just the same code as HERE
                dex
                dex
                sty.dx 00

                ldy.d cp

z_begin         rts


; -------------------------------------------------------------------
; BL ( -- u ) 7 bytes / 12 cycles
; Put ASCII char for SPACE on Data Stack
xt_bl            
        .!xy16
                dex
                dex
                sty.dx 00
                ldy.# AscSP

z_bl            rts


; -------------------------------------------------------------------
; BOUNDS ( addr u -- addr+u addr ) 9 bytes / X cycles
; Given a string, return the correct Data Stack parameters for a DO/LOOP loop
; over its characters. This is realized as OVER + SWAP in Forth, but we do it
; a lot faster in assembler. Uses tmptos
xt_bounds        
        .!a16
                sty.d tmptos
                ldy.dx 00       ; addr now TOS

                clc
                adc.d tmptos
                sta.dx 00       ; addr+u now NOS
                
z_bounds        rts


; -------------------------------------------------------------------
; BRANCH ( -- ) X bytes / X cycles
; Transfer control to given address. Uses tmp3 and tmptos. This word was adapted
; from Tali Forth and will be replaced by ANSI-conform words CS-PICK and CS-ROLL 
; in the future
xt_branch        
        .!a16
                ; encode subroutine branch to runtime portion
                phe.# branch_rt
                jsr cmpl_subroutine

z_branch        rts

branch_rt
                sty.d tmptos

                ; The value on the Return Stack determines where we go to
                pla
                sta.d tmp3
                ldy.# 0001
                lda.diy tmp3    ; LDA (TMP1),Y ; get address we're pointing to
                dec.a
                pha             ; put target address back on Return Stack 

                ldy.d tmptos

                rts

; -------------------------------------------------------------------
; BYE ( -- ) 2 bytes / 7-8 cycles
; Leave Liara Forth, returning to Mensch Monitor
; TODO make sure this actually calls the MM
xt_bye           
                cli
                brk 00  ; status byte 00 required for assembler

z_bye           rts     ; dummy for compiling, never reached


; -------------------------------------------------------------------
; C, "C-COMMA" ( char -- ) 13 bytes / 28 cycles
; Store one character in the Dictionary
xt_c-comma       
                tya
        .a8
                sta.di cp       ; STA (CP)
        .a16
                inc.d cp        ; quick version of 1 ALLOT

                ldy.dx 00
                inx
                inx

z_c-comma       rts


; -------------------------------------------------------------------
; C@ "C-FETCH" ( addr -- n ) 11 bytes / 16 cycles
; Get a single byte from the given address
xt_c-fetch       
        .a8
                lda.y 0000
        .a16
                and.# 00ff
                tay

z_c-fetch       rts


; -------------------------------------------------------------------
; C! "C-STORE" ( n addr -- ) 15 bytes / 29 cycles
; Store LSB of NOS at location given as TOS
xt_c-store       
                lda.dx 00
        .a8
                sta.y 0000
        .a16
                ldy.dx 02
                inx
                inx
                inx
                inx
                
z_c-store       rts


; -------------------------------------------------------------------
; CELL+ ( u -- u+2 ) X bytes / X cycles
; Add the size of one cell to the value on top of the stack. Since this is
; a 16-bit cell size, we add two
xt_cellplus         
                iny
                iny
z_cellplus      rts


; -------------------------------------------------------------------
; CELLS ( n -- n ) X bytes / X cycles
; Given a number of cells, return the number of bytes that they will require.
; This is 16 bit cell Forth, so the value returned by this word is the same as
; returned by 2*, see there. 

; -------------------------------------------------------------------
; CHAR ( "c" -- u ) 23 bytes / X cycles
; Convert a character to its ASCII value
xt_char          
        .!a16
                jsr xt_parse-name       ; ( -- addr u ) 

                ; if we got back a zero, we have a problem
                tya                     ; force flag check
                bne char_got_char

                lda.# es_noname
                jmp error

char_got_char
                ldy.dx 00               ; get addr from NOS
                lda.y 0000              ; LDA 0000,Y - could be C@
                and.# 00ff
                tay
                
                inx
                inx
                
z_char          rts
 

; -------------------------------------------------------------------
; CHARPLUS ( u -- u+1 ) X bytes / X cycles
; Adds the size of a character to the value on top of the stack. Since our
; character size is one, this is the same code as 1+, see there


; -------------------------------------------------------------------
; CHARS ( u -- u ) X bytes / X cycles
; Return the size in bytes of the number of characters on the top of the stack.
; In this case, does nothing
xt_chars         

                nop
z_chars         rts


; -------------------------------------------------------------------
; COMPILE-ONLY ( -- ) 8 bytes / X cycles
; Mark the most recently defined word as COMPILE-ONLY. The alternative (and
; traditional) way to do this is to include a word ?COMPILE that makes sure
; we're in compile mode
xt_compile-only  
        .!a16
                lda.# CO
                xba             ; flags are MSB
                ora.di dp       ; ORA (DP)
                sta.di dp

z_compile-only  rts


; -------------------------------------------------------------------
; COMPILE, ( xt -- ) X bytes / X cycles
; Compile a given xt in the current word definition. It is an error if we are
; not in the compile state. Because we are using subroutine threading, we can't
; use , (COMMA) to compile new words the traditional way. We use the NC (Native
; Compile) flag to decide if native compilation is allowed. If yes, we use the
; value NC_LIMIT (in definitions.tasm) to decide if the code is too large to be
; natively coded: If the size is smaller than NC_LIMIT, we silently use
; subroutine coding. 
; TODO currently just compiles subroutine jumps
xt_compilecomma  

compile_as_code
                ; Compile xt as native code
                ; use nc_limit to decide if we want native compile
                ; TODO consider special cases: 
                ;  - >R R> R@ should strip PLA/PHA if native compiled
                ;  - Don't compile comments

compile_as_jump
                ; Compile xt as a subroutine jump. We don't have to switch A to
                ; 8-bit register size because we only advance CP by one byte, so
                ; the MSB of A is overwritten. Little endian machines for the
                ; win!
                lda.# 20        ; opcode for JSR
                sta.di cp       ; STA (CP)
                inc.d cp

                ; There is no "sty.di" instruction, so we have to do this the
                ; hard way
                tya
                sta.di cp
                inc.d cp
                inc.d cp

                ldy.dx 00
                inx
                inx
                
z_compilecomma  rts


; -------------------------------------------------------------------
; CONSTANT ( "name" n -- ) X bytes / X cycles
; Associate a fixed value with a word. This could be realized as 
; CREATE , DOES> @  as well. We do more in assembler but let CREATE do the heavy
; lifting. 
; See http://www.bradrodriguez.com/papers/moving3.htm for a primer on how
; this works in various Forths. 
xt_constant      
                jsr xt_create

                ; CREATE by default installs a subroutine jump to DOVAR, but we
                ; actually want DOCONST this time. Go back two bytes and repace
                ; the subroutine jump target
                lda.d cp
                dec.a
                dec.a
                sta.d tmp1

                lda.# doconst
                sta.di tmp1     ; STA (TMP1)

                ; Save TOS in next cell. This is a direct version of COMMA
                tya             ; there is no "sty.di cp"
                sta.di cp
                inc.d cp
                inc.d cp

                ldy.dx 00       ; DROP
                inx
                inx

z_constant      rts


; -------------------------------------------------------------------
; COUNT ( c-addr -- addr u ) 14 bytes / X cycles
; Convert old-style character string to address-length pair. Note that the
; length of the string c-addr ist stored in character length (8 bit), not cell
; length (16 bit). This is rarely used these days, though COUNT can also be used
; to step through a string character by character. 
xt_count         
        .!a16
        .!xy16
                tya
                inc.a           ; String address starts one char later

                dex
                dex
                sta.dx 00       ; NOS
                
                lda.y 0000      ; LDA $0000,Y  first byte is length
                xba             ; move length to LSB
                and.# 00ff      ; get rid of whatever was MSB
                tay             ; TOS
                
z_count         rts


; -------------------------------------------------------------------
; CR ( -- ) X bytes / X cycles
; Cause following output to appear at beginning of next line
; TODO replace with EMIT
xt_cr            
                lda.# AscLF     ; test with AscCR for emulators
                jsr put_chr

z_cr            rts

; -------------------------------------------------------------------
; CREATE ( "name" -- ) X bytes / X cycles
; Create a Dictionary entry associated with "name", used for various words,
; especially for VARIABLE. When called, this new word will return the associated
; address.
xt_create        
        .!a16
                jsr xt_parse-name        ; ( -- addr u ) 
                bne create_got_name

                ; if we got a zero-length name string, complain and abort
                lda.# es_noname
                jmp error 

create_got_name
                ; all Dictionary entries are lowercase
                jsr string_to_lowercase 

                ; Remember the first free byte of memory as the start of the new
                ; word
                lda.d cp
                sta.d tmp1              ; save start of new word

                ; Enforce limit on 255 char length names by masking the MSB
                ; of the length of the given string. We arrive here with 
                ; ( addr u ) 
                tya
                and.# 00ff
                sta.d tmp2      ; save length of name string

                ; We need 8 bytes + the length of the name string for our new
                ; header. This is also the offset for the start of the code
                ; field (the xt_ label) so we need to remember it. Otherwise, we
                ; could just allot the space afterwards. 
                clc
                adc.# 0008
                sta.d tmp3      ; total bytes required for header

                ; We need to allocate three more bytes for the hardcoded
                ; code field area (CFA), the "payload" of the word which by
                ; default will be a subroutine jump to DOVAR
                inc.a
                inc.a
                inc.a

                ; Instead of jumping to ALLOT, we do things by hand for speed
                ; and so we don't have to fool around with the stack
                clc
                adc.d cp
                sta.d cp 

                ; Now we walk through the header, using Y as the index. See
                ; drawing of header in headers.tasm file for reference. We
                ; arrive here with ( addr u ) still from PARSE-NAME. We need
                ; that addr later for the name string, so we push it to the
                ; Return Stack. We'll clean up the Data Stack later
                lda.dx 00
                pha

                ; HEADER BYTES 0,1: Length byte and flags
                ldy.# 0000      ; Y is now an index, not TOS
                lda.d tmp2      ; get length byte
                sta.diy tmp1    ; STA (TMP1),Y
                iny
                iny

                ; BYTES 2,3: Next word in the dictionary (its nt). This is the
                ; current Dictionary Pointer
                lda.d dp
                sta.diy tmp1
                iny
                iny
                
                ; BYTES 4,5: Start of code field (xt of this word, "xt_" link)
                ; This begins after the header, so we take the length of the
                ; header, which we saved in tmp3, and use it as an offset to 
                ; the address of the start of the word
                lda.d tmp1      ; can't use CP, because we've allotted space
                sta.d dp        ; while we've got it, make old CP the new DP

                clc
                adc.d tmp3      ; total header length
                sta.diy tmp1
                iny
                iny
               
                ; BYTES 6,7: End of code ("z_" link)
                ; By default, we execute a jump to the DOVAR routine, so we need
                ; to move three bytes down, and then one more byte so the z_
                ; label points to the (fictional) RTS instruction for correct
                ; compilation. The start of the code field is still in A
                inc.a
                inc.a
                inc.a
                sta.diy tmp1
                iny
                iny

                ; BYTE 8: Start of name string
                ; The addr of the string is on the Return Stack, the length of
                ; the name string is in tmp2. We subtract eight from the address
                ; so we can use the same loop index
                pla             ; get back string address
                sec
                sbc.# 0008
                sta.d tmp3
        .a8
@
                lda.diy tmp3 
                sta.diy tmp1
                iny
                dec.d tmp2
                bne - 

                ; After the name string, comes the Code Field (start at xt, that
                ; is, the xt_ label of the word) which is initially a jump to the
                ; subroutine to DOVAR. We're still in 8-bit A-register, which is
                ; good
                lda.# 20        ; opcode of JSR
                sta.diy tmp1
                iny             ; single increase only because we have 8-bit A 

                lda.# .lsb dovar 
                sta.diy tmp1
                iny

                lda.# .msb dovar
                sta.diy tmp1

        .a16
                ; We're done. Restore Data Stack (2DROP)
                ldy.dx 02
                inx
                inx
                inx
                inx
                
z_create        rts


; -------------------------------------------------------------------
; DIGIT? ( char -- u f | char f )  X bytes / X cycles
; Convert a single ASCII character to a number in the current radix. Inspired by
; the pForth instruction DIGIT in pForth, see
; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
; Rewritten from DIGIT>NUMBER in Tali Forth. Note in contrast to pForth, we get
; the base (radix) ourselves instead of having the user provide it. There is no
; standard name for this routine, which itself is not ANSI; we use DIGIT?
; following pForth and Gforth. 
xt_digitq
        .!a16
                tya
                and.# 00ff              ; paranoid

        .a8 
                ; Make sure we're not below the ASCII code for '0'
                cmp.# '0'
                bcc dq_notdigit

                ; Then see if we are below '9', because that would make this
                ; a normal number
                cmp.# { '9' + 1 }       ; This is ':'
                bcc dq_checkbase

                ; Well, then let's see if this is the gap between '9' and 'A' so
                ; we can treat the whole range as a number
                cmp.# { 'A' - 1 }       ; This is '@'
                bcc dq_notdigit

                ; Probably a letter, so we make sure it is uppercase
                cmp.# 'a'
                bcc dq_case_done        ; not lower case, too low
                cmp.# { 'z' + 1 }
                bcs dq_case_done        ; not lower case, too high

                clc                     ; just right
                adc.# e0                ; offset to uppercase (wraps)

dq_case_done
                ; Get rid of the gap between '9' and 'A' so we can treat the
                ; whole range as one number
                sec
                sbc.# 07                ; fall through to dq_checkbase

dq_checkbase
                ; We have a number, now see if it inside the range given by BASE
                sec
                sbc.# '0'               ; This is also the actual conversion step
                cmp.d base
                bcc dq_success
                
dq_notdigit
                ; not a digit, add a false flag
                dex
                dex
                sty.dx 00       ; keep the offending character in NOS
                ldy.# 0000
        .a16
                bra z_digitq

dq_success
                dex
                dex
        .a16
                sta.dx 00       ; put the number in NOS
                ldy.# 0ffff
                
z_digitq        rts


; -------------------------------------------------------------------
; DPLUS ( d d -- d ) X bytes / X cycles
; Add two double cell numbers. 
xt_dplus         
        .!a16
                phy             ; save hi word of first number, frees Y
                lda.dx 00       ; lo word of first number
                clc
                adc.dx 04       ; add lo word of second number
                tay

                pla             ; get hi word of first number
                adc.dx 02       ; add hi word of second number

                inx
                inx
                inx
                inx
                
                sty.dx 00       ; lo result goes NOS
                tay             ; to result goes TOS

z_dplus         rts

; -------------------------------------------------------------------
; D>S ( ud -- u ) X bytes / X cycles
; Convert double cell number to single cell. Note this currently does not
; respect the sign, in constrast to Gforth - this is simply DROP
; TODO make this work the way Gforth's does
xt_dtos          
        .!a16
                ldy.dx 00
                inx
                inx 

z_dtos          rts


; -------------------------------------------------------------------
; DABS ( d -- ud ) X bytes / X cycles
; Return the absolute value of a double number
; TODO recode in assembler
xt_dabs          
                ; double cell is TOS 
                tya             ; force flag test
                beq z_dabs      ; already positive, life is good

                jsr xt_dnegate

z_dabs          rts


; -------------------------------------------------------------------
; DECIMAL ( -- ) 7 bytes / X cycles
; Change radix for number conversion to 10
xt_decimal       
        .!a16
                lda.# 000a
                sta.d base

z_decimal       rts


; -------------------------------------------------------------------
; DEPTH ( -- u ) 14 bytes / X cycles
; Push the number of entries in cells (not bytes) on the parameter stack.
; Assumes X is valid as the DSP.
xt_depth         
        .!a16
                ; We've got zero entries when X is dsp0
                stx.d tmpdsp
                lda.# dsp0
                sec
                sbc.d tmpdsp

                ; now divide by two because each cells is to bytes long
                lsr.a

                dex
                dex
                sty.dx 00

                ; push result to stack
                tay

z_depth         rts

; -------------------------------------------------------------------
; DNEGATE ( d -- d ) 19 bytes / X cycles
; Change the sign of a double number. This is the double equivalent of NEGATE
xt_dnegate       
        .!a16
                ; start off with LSW (in NOS)
                lda.dx 00
                eor.# 0ffff

                ; INC doesn't affect the carry flag, so we have to do this the
                ; hard way
                clc
                adc.# 0001
                sta.dx 00

                ; now MSW (in TOS)
                tya
                eor.# 0ffff
                adc.# 0000      ; we are only interested in the carry
                tay
             
z_dnegate       rts


; -------------------------------------------------------------------
; DOES> ( -- ) X bytes / X cycles
; Create the payload for defining new defining words. See the file
; docs/create-does.txt and 
; http://www.bradrodriguez.com/papers/moving3.htm for a discussion of 
; DOES>'s internal workings. This uses tmp1 and tmp2
xt_does
                ; compile a subroutine jump to the runtime of DOES>
                phe.# does_rt
                jsr cmpl_subroutine

                ; compile a subroutine jump to DODOES. In traditional terms,
                ; this is the Code Field Area (CFA) of the new word
                phe.# dodoes
                jsr cmpl_subroutine
                
z_does          rts

does_rt
                ; Runtime portion of DOES>. This replaces the subroutine jump to
                ; DOVAR that CREATE automatically encodes by a jump to the
                ; address that contains a subroutine jump to DODOES. We don't
                ; jump to DODOES directly because we need to work our magic with
                ; the return addresses
                pla
                inc.a           ; increase by one because of RTS mechanics
                sta.d tmp1

                ; CREATE has also already modified the DP to point to the new
                ; word. We have no idea which instructions followed the CREATE
                ; command if there is a DOES> so the CP could point anywhere by
                ; now.
                lda.d dp

                ; The address of the word's xt is four bytes down (see
                ; header.tasm for details).
                clc
                adc.# 0004
                sta.d tmp2

                ; Now we get that address and add one byte to skip over the JSR
                ; opcode
                lda.di tmp2     ; LDA (TMP2)
                inc.a
                sta.d tmp2      ; Points to address to be replaced

                ; Replace the DOVAR address
                lda.d tmp1
                sta.di tmp2     ; STA (TMP2)

                ; Since we removed the return address that brought us here, we
                ; go back to whatever the main routine was. Otherwise, we we
                ; smash into the subroutine jump to DODOES.
                rts
                

; -------------------------------------------------------------------
; DROP ( n -- ) 4 bytes / 9 cycles
; Drop first entry on Data Stack

xt_drop          
        .!xy16
                ldy.dx 00 
                inx
                inx

z_drop          rts


; -------------------------------------------------------------------
; DUMP ( addr u -- ) X bytes / X cycles
; Print region of memory in a pretty way. 
; TODO This is a crude, temporary version for testing. Rewrite ASAP
xt_dump          
                ; we use tmp1 as a counter because we need Y for other
                ; stuff
                sty.d tmp1

dump_line_loop
                jsr xt_cr
                
                ; start internal counter for 16 numbers per row
                ldy.# 0010
dump_byte_loop
                ; if there are zero bytes left to display, we're done
                lda.d tmp1
                beq dump_done

                ; otherwise, print contents pointed to by address in NOS
                lda.dxi 00
                jsr byte_to_ascii       ; TODO replace by EMIT
                jsr xt_space

                ; next character
                inc.dx 00

                ; loop counter
                dec.d tmp1
                dey
                bne dump_byte_loop
                bra dump_line_loop
                
dump_done
                jsr xt_cr 

                ; drop everything and return
                ; TODO replace by call of 2DROP
                ldy.dx 02
                inx
                inx
                inx
                inx
                
z_dump          rts


; -------------------------------------------------------------------
; DUP  ( n -- n n ) 4 bytes / 9 cycles
; Duplicate first entry on Data Stack

xt_dup           
        .!xy16
                dex
                dex
                sty.dx 00

z_dup           rts


; -------------------------------------------------------------------
; EVALUATE ( addr u -- ) X bytes / X cycles
; Execute string. Set SOURCE-ID to -1, make addr u the input source, 
; set >IN to zero. After processing the line, revert to old input source. 
xt_evaluate      
                ; We follow pforth's procedure of pushing SOURCE, SOURCE-ID, and
                ; >IN to the Return Stack
                lda.d toin      ; >IN
                pha
                lda.d insrc     ; Input Source (SOURCE-ID)
                pha
                lda.d cib
                pha
                lda.d ciblen
                pha

                ; set SOURCE-ID to -1
                lda.# 0ffff
                sta.d insrc

                ; set >IN to zero
                stz.d toin

                ; move TOS and NOS to input buffers
                sty.d ciblen
                lda.dx 00
                sta.d cib

                ; dump address string from stack
                ldy.dx 02
                inx
                inx
                inx
                inx

                jsr interpret

                ; restore state from before evaluate
                pla
                sta.d ciblen
                pla
                sta.d cib
                pla
                sta.d insrc
                pla
                sta.d toin
                
z_evaluate      rts


; -------------------------------------------------------------------
; EXECUTE ( xt -- ) X bytes / X cycles
; Run a word with help of its xt on the TOS

; Reserve three bytes for the jump - three in case we want to expand to the full
; range
; TODO move this to someplace that is assured to be RAM, not possibly ROM
execute_ip      .byte 00, 00, 00    

xt_execute       
        .!a16
        .!xy16
                ; Store the xt for later use and then drop it off the stack
                sty execute_ip
                ldy.dx 00
                inx
                inx

                ; Only JMP has the addressing mode we need. All our Forth
                ; words end with a RTS instruction, so they will take us back to
                ; the original caller of this routine without us having to muck
                ; about with the Return Stack. 
                jmp.i execute_ip        ; JMP (EXECUTE_IP)
  
z_execute       nop             ; Never reached, see if we need the NOP
                

; -------------------------------------------------------------------
; FALSE ( -- f ) 7 bytes / 12 cycles
; Pushes value $0000 for Forth true on Data Stack. This is the same code as for 
; ZERO, see there. Dictionary entry should have xt_zero/z_zero instead of
; xt_false/z_false

; -------------------------------------------------------------------
; FIND-NAME ( addr u -- nt | 0 ) 91 bytes / X cycles
; Given a string, find the Name Token (nt) of a word or return zero if the word
; is not in the dictionary. We use this instead of ancient FIND to look up words
; in the Dictionary passed by PARSE-NAME. Note this returns the nt, not the xt
; of a word like FIND. To convert, use NAME>INT. This is a Gforth word. See
; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html 
; FIND calls this word for the hard word
xt_find-name     
                ; We abort when we get an empty string, that is, one with
                ; a length of zero TOS. We could test for this, but it will
                ; happen so rarely that the speed penalty is higher if we run
                ; the test for every single call. Looking for an empty string
                ; does force us to check the whole dictionary, though. The test
                ; would be 3 bytes and 4 to 6 cycles longer: 
                ;       tya                     ; force flag check
                ;       beq find-name_failure
        .!a16
        .!xy16
                ; set up loop for the first time
                sty.d tmptos    ; length of mystery string in tmptos, Y now free

                ldy.d dp
                sty.d tmp1      ; nt of first Dictionary word 

                ldy.dx 00 
                sty.d tmp2      ; address of mystery string, was NOS

find-name_loop
                ; First quick test: Are strings the same length?
                lda.di tmp1     ; LSB in first header word is length
                and.# 00ff      
                cmp.d tmptos    ; we test LSB
                ; Most of the time, it will not be the same, so we save one
                ; cycle pro loop if we only take the branch when they are the
                ; same
                beq find-name_chars

find-name_next_entry
                ; next header address is two bytes down
                inc.d tmp1
                inc.d tmp1
                lda.di tmp1     ; LDA (TMP1) 

                ; a zero entry marks the end of the Dictionary
                beq find-name_failure_16

                sta.d tmp1      ; new header 
                bra find-name_loop

find-name_chars
                ; Yes, same length, so we compare characters

                ; Switch A to 8 bit for this 
        .a8
                ; Second quick test: Check first char, which is 8 bytes into the
                ; header 
                ldy.# 0008
                lda.diy tmp1    ; LDA (TMP1),Y - first char of entry
                cmp.di tmp2     ; CMP (TMP2) - first char of mystery string
                beq find-name_all_chars
                
find-name_char_nomatcnt_8
                ; First char is not the same, next entry
        .a16
                bra find-name_next_entry

find-name_all_chars
        .!a8
                ; String length is the same, and the first character is the
                ; same. If the word is only one character long, we're done
                ldy.d tmptos
                dey             ; faster and shorter than CPY.# 01
                beq find-name_success
                
                ; No such luck: The strings are the same length and the first
                ; char is the same, but the word is more than one char long. So
                ; we suck it up and compare every single character. We go from
                ; back to front, because words like CELLS and CELL+ would take
                ; longer otherwise. We can also shorten the loop by one because
                ; we've already compared the first char. 

                ; Even worse, we have to add 8 bytes to address of Dictionary
                ; string to allow testing with one loop. We need this like
                ; a hole in the head because we just switched A to 8 bit.
                ; However, staying with an 8-bit A is even slower.
        .a16
                lda.d tmp1      ; address of Dictionary string
                clc
                adc.# 0008 
                sta.d tmp3
        .a8
                ldy.d tmptos    ; get length of strings as loop index
                dey             ; first index is length minus 1

@
                lda.diy tmp2    ; LDA (TMP2),Y - last char of mystery string
                cmp.diy tmp3    ; CMP (TMP1),Y - last char of DP string
                bne find-name_char_nomatcnt_8
                dey             ; start of string (Y=0) was already tested
                bne -
                
find-name_success
                ; If we reach here, the strings are the same and we have a match
                ; We get here with an 8 bit A
        .a16    
                ldy.d tmp1      ; get the correct DP
                bra find-name_done


find-name_failure_16
                ; Word not found in Dictionary, return zero. Assumes A is 16
                ; bit
                ldy.# 0000      ; fall thru 

find-name_done
                inx             ; drop old address (NIP)
                inx

z_find-name     rts


; -------------------------------------------------------------------
; IMMEDIATE ( -- ) X bytes / X cycles
; Mark the most recently defined word as IMMEDIATE. Will only affect the last
; word in the Dictionary. If the words is still in ROM for some reason, this
; will have no effect and will fail without an error message
xt_immediate     
        .!a16
                lda.# IM        ; Immediate flag
                xba             ; flags are MSB
                ora.di dp       ; ORA (DP)
                sta.di dp
                
z_immediate     rts


; -------------------------------------------------------------------
; INVERT ( n -- n ) 5 bytes / X cycles
; Complement of TOS
xt_invert        
        .!a16
                tya
                eor.# 0ffff
                tay

z_invert        rts


; -------------------------------------------------------------------
; HERE ( -- u ) 6 bytes / 13 cycles
; Push Compiler Pointer address on the Data Stack
xt_here          
        .!xy16
                dex
                dex
                sty.dx 00

                ldy.d cp

z_here          rts

; -------------------------------------------------------------------
; HEX ( -- ) X bytes / X cycles
; Change radix for number conversion to 16
xt_hex           
        .!a16
                lda.# 0010
                sta.d base

z_hex           rts

; -------------------------------------------------------------------
; HOLD ( char -- ) X bytes / X cycles
; Insert a character at the current position of a pictured numeric output string
; Code based on https://github.com/philburk/pforth/blob/master/fth/numberio.fth
; Forth code is : HOLD  -1 HLD +!  HLD @ C! ;  We use the the internal variable
; tohold instead of HLD.
xt_hold          
        .!a16
                dec.d tohold    ; -1 HLD +!

                tya
        .a8
                sta.di tohold   ; STA (TOHOLD)
        .a16
                ldy.dx 00
                inx
                inx

z_hold          rts

; -------------------------------------------------------------------
; LATESTNT ( -- nt ) 7 bytes / X cycles
; Return the name token (nt) of the last word in the Dictionary. The Gforth
; version of this word is called LATEST. 
xt_latestnt      
        .!a16
                dex             ; make room on Data Stack
                dex
                sty.dx 00

                lda.d dp
                tay

z_latestnt      rts


; -------------------------------------------------------------------
; LATESTXT ( -- xt ) 11 bytes / X cycles
; Return the name token (xt) of the last word in the Dictionary. This is simply
; LATESTNT but four bytes down and with a FETCH
xt_latestxt      
        .!a16
                dex             ; make room on Data Stack
                dex
                sty.dx 00

                lda.d dp

                clc             ; xt is stored four bytes below nt in header
                adc.# 0004
                tay

                lda.y 0000      ; FETCH
                tay

z_latestxt      rts


; -------------------------------------------------------------------
; LITERAL ( n -- ) X bytes / X cycles
; Compile-only word to store TOS so that it is pushed on stack during runtime.
; This is a immediate, compile-only word. Test it with  : AAA [ 1 ] LITERAL ;
; for instance
xt_literal       
                ; During runtime, we call the routine at the bottom by compiling 
                ; JSR LITERAL_RT. Note the cmpl_ routines use tmptos
                phe.# literal_rt        ; PEA LITERAL_RT
                jsr cmpl_subroutine

                ; compile the value that is to be pushed to the Data Stack at
                ; runtime. There is no "sty.di", so we have to do this the hard
                ; way. This is basically , ("comma") 
                tya
                sta.di cp
                inc.d cp
                inc.d cp

                ldy.dx 00               ; DROP
                inx
                inx

z_literal       rts

literal_rt
                ; During runtime, we push the value following this word
                ; back on the Data Stack. The subroutine jump that brought us
                ; here put the address to return to on the Return Stack - this
                ; points to the data we need to get

                ; Make room on Data Stack, Y now free to use
                dex
                dex
                sty.dx 00

                ; The 65816 stores (<RETURN-ADDRESS> - 1) on the Return Stack
                ; so we have to manipulate the address
                ply
                iny
                lda.y 0000      ; LDA $0000,Y - get value after jump

                iny             ; move return address past data and restore
                phy             ; so we can get back home

                tay             ; Value is now on the Data Stack ( -- n )

                rts

; -------------------------------------------------------------------
; M* "MSTAR" ( n n -- d ) 16*16 -> 32  X bytes / X cycles
; Multiply two 16 bit numbers, producing a 32 bit result. All values are signed.
; This was originally adapted from FIG Forth for Tali Forth. The original Forth
; code is : M* OVER OVER XOR >R ABS SWAP ABS UM* R> D+- ;  with 
; : D+- O< IF DNEGATE THEN ; 
; TODO Test this more once we have the Double words etc all working
xt_mstar         
        .!a16
                ; figure out the sign
                tya             
                eor.dx 00

                ; um* uses all kinds of tmp stuff so we don't risk a conflict
                ; and just take the cycle hit by pushing this to the stack
                pha

                ; get the absolute value of both numbers so we can feed them to
                ; UM*, which does the real work
                tya
                bpl mstar_abs_nos
              
                ; TOS is negative so we have to ABS it
                eor.# 0ffff
                inc.a
                tay

mstar_abs_nos
                lda.dx 00
                bpl mstar_umstar
                
                ; NOS is negative so we have to ABS it
                eor.# 0ffff
                inc.a
                sta.dx 00

mstar_umstar
                jsr xt_umstar   ; now ( d ) on stack

                ; handle the sign
                pla

                ; postive, we don't have to care
                bpl z_mstar

                jsr xt_dnegate

z_mstar         rts


; -------------------------------------------------------------------
; MAX ( n m -- n ) 18 bytes / X cycles
; Compare TOS and NOS and keep which one is larger. Adapted from Lance A.
; Leventhal "6502 Assembly Language Subroutines". Negative Flag indicates which
; number is larger. See also http://6502.org/tutorials/compare_instructions.html
; and http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html 
xt_max           
                tya
                cmp.dx 00
                
                ; If they are the same, life is good. This step also sets the
                ; Carry flag
                beq max_nip     ; Faster than DROP because TOS is in Y

                sbc.dx 00
                bvc max_no_ov   ; no overflow, skip ahead

                ; Deal with oveflow because we use signed numbers
                eor.# 8000      ; compliment negative flag

max_no_ov
                bpl max_nip     ; keep TOS
max_drop
                ldy.dx 00       ; DROP so NOS is result 
max_nip
                inx
                inx
                
z_max           rts


; -------------------------------------------------------------------
; MIN ( n m -- n ) 18 bytes / X cycles
; Compare TOS and NOS and keep which one is smaller Adapted from Lance A.
; Leventhal "6502 Assembly Language Subroutines". Negative Flag indicates which
; number is larger. See also http://6502.org/tutorials/compare_instructions.html
; and http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html 
xt_min           
                tya
                cmp.dx 00
                
                ; If they are the same, life is good. This step also sets the
                ; Carry flag
                beq min_nip     ; Faster than DROP because TOS is in Y

                sbc.dx 00
                bvc min_no_ov   ; no overflow, skip ahead

                ; Deal with oveflow because we use signed numbers
                eor.# 8000      ; compliment negative flag

min_no_ov
                bmi min_nip     ; keep TOS
min_drop
                ldy.dx 00       ; DROP so NOS is result 
min_nip
                inx
                inx
                
z_min           rts


; -------------------------------------------------------------------
; NAME>INT ( nt -- xt ) 4 bytes / 8 cycles
; Given the Name Token (nt) of a word, return its Execute Token (xt)
xt_name-int      
        .!a16
        .!xy16
                ; The xt of a word beginns four bytes down from its nt
                iny
                iny
                iny
                iny
                lda.y 0000
                tay
                
z_name-int      rts

; -------------------------------------------------------------------
; NAME>STRING ( nt -- addr u ) 16 bytes / X cycles
; Given a name token (nt) of a word, return its string. This is a Gforth word
; that works with the Dictionary header entries. It is not checked if nt is
; a valid name token. 
xt_name-string   
        .!a16
        .!xy16
                dex             ; move NOS down one
                dex

                ; the name string of a word begins 8 bytes down from its nt,
                ; which we have as TOS
                tya
                clc
                adc.# 0008
                sta.dx 00       ; NOS
                
                ; the length of the name string is in the LSB of the first word
                ; of the dictionary entry header (the name token)
                lda.y 0000      ; LDA $0000,Y
                and.# 00ff      ; mask all but length byte
                tay
                
z_name-string   rts


; -------------------------------------------------------------------
; NEGATE ( n -- n ) 6 bytes / X cycles
; Two's complement of TOS
xt_negate        
                tya
                eor.# 0ffff
                inc.a
                tay

z_negate        rts


; -------------------------------------------------------------------
; NIP ( n m -- m ) 2 bytes / 4 cycles
; Delete entry that is NOS
xt_nip           
        .!xy16
                inx
                inx
z_nip           rts


; -------------------------------------------------------------------
; NUMBER ( addr u -- u | d ) X bytes / X cycles
; Convert a number string to a double or single cell number. This is a wrapper
; for >NUMBER and follows the convention set out in the "Forth Programmer's
; Handbook" (Conklin & Rather) 3rd edition p. 87. Based in part on the "Starting
; Forth" code https://www.forth.com/starting-forth/10-input-output-operators/
; Gforth uses S>NUMBER? and S>UNUMBER? which return the numbers and a flag, see
; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Number-Conversion.html
; Another difference to Gforth is that we follow ANSI Forth that the dot to
; signal a double cell number is required to be the last character of the
; string. Number calls >NUMBER which in turn calls UM*, which uses tmp1, tmp2,
; and tmp3, so we can't use them here, which is pain. 
xt_number        
        .!a16
                ; The flags for sign and double are kept on the stack because
                ; we've run out of temporary variables. MSB is for minus, LSB is
                ; for double
                phe.# 0000

                sty.d tmptos    ; save length of string, freeing Y

                ; if the first character is a minus, strip it off and set
                ; a flag
        .a8
                lda.dxi 00      ; get first character
                cmp.# '-'
        .a16                    ; zero flag is uneffected
                bne number_dot

                ; We have a minus. 
                pla
                ora.# 0ff00     ; MSB is minus
                pha

                inc.dx 00       ; start one character later
                dec.d tmptos    ; reduce string length by one

number_dot
                ; if the last character is a dot, strip it off and set a flag
                lda.d tmptos    ; get the string length
                dec.a           ; subtract one to convert length to index
                clc
                adc.dx 00       ; add length of string
                tay
        .a8
                lda.y 0000      ; get last character
                cmp.# '.'
        .a16
                bne number_main
                
                ; we have a dot
                pla             ; get the flag back
                ora.# 00ff      ; LSB is double
                pha

                dec.d tmptos    ; reduce string length by one

number_main
                ; set up stack for subroutine jump to >NUMBER 
                lda.dx 00       ; get the string address to safety
                stz.dx 00       ; NOS is now zero
                dex
                dex
                stz.dx 00       ; 3OS and NOS are now zero
                dex
                dex

                sta.dx 00       ; address is back as NOS
                ldy.d tmptos    ; length is back as TOS
        
number_loop
                jsr xt_tonumber ; ( ud addr u -- ud addr u ) 

                tya             ; test length of returned string, should be 0
                beq number_ok

                ; Something went wrong during conversion, we still have stuff
                ; left over. Print error string and abort. If number was called
                ; by INTERPRET, we've already checked for words, so we're in
                ; trouble one way or another
                ; TODO print offending string
                lda.# es_syntax
                jmp error
                
number_ok
                ; All characters successfully converted. Drop the string info
                ldy.dx 02
                inx
                inx
                inx
                inx

                ; We have a double-cell number on the Data Stack that might have
                ; a minus and might actually be single-cell
                pla             ; get copy of the flags
                pha
                and.# 00ff      ; only keep the part with the number size (LSB)
                beq number_single
                
                ; This is a double-cell number. If it had a minus, we'll have to
                ; negate it
                pla
                and.# 0ff00     ; only keep part with the sing (MSB)
                beq z_number    ; no minus, all done
                
                lda.dx 00       ; DNEGATE, starts with LSW
                eor.# 0ffff

                ; INC won't affect the carry flag, so we have to do this the
                ; hard way
                clc
                adc.# 0001
                sta.dx 00

                ; now MSW (in TOS)
                tya
                eor.# 0ffff
                adc.# 0000      ; we are only interested in the carry
                tay
 
                bra z_number

number_single                
                ; This is a single cell number, so we just drop the top cell
                ldy.dx 00
                inx
                inx
                
                ; If we have a minus, we'll have to negate it. Note this code is
                ; doubled for speed
                pla
                and.# 0ff00
                beq z_number    ; no minus, all done
                
                tya             ; NEGATE
                eor.# 0ffff
                inc.a
                tay             ; fall through to end
               
z_number        rts


; -------------------------------------------------------------------
; OR ( n m -- n ) 6 bytes / X cycles
; Logical OR
xt_or            
                tya
                ora.dx 00
                tay

                inx
                inx

z_or            rts


; -------------------------------------------------------------------
; OVER ( n m -- n m n )  6 bytes / 14 cycles
; Push NOS on Data Stack
xt_over          
                dex 
                dex
                sty.dx 00
                ldy.dx 02
                
z_over          rts


; -------------------------------------------------------------------
; PAD ( -- addr ) 11 bytes / X cycles
; Return address to a temporary area in free memory for user. Must be at least 
; 84 bytes in size (says ANSI). It is located relative to the compile area
; pointer (CP) and therefore varies in position. This area is reserved for the
; user and not used by the system
xt_pad           
        .!a16
                dex
                dex
                sty.dx 00

                lda.d cp
                clc
                adc.# padoffset
                tay
                
z_pad           rts


; -------------------------------------------------------------------
; PAGE ( -- ) X bytes / X cycles
; Clear the screen on vt-100 terminals by sending the code "ESC[2J". This is
; only useful in interactive scenarios so we don't worry about speed
; TODO rewrite with EMIT
xt_page          
                lda.# vt100_page
                jsr print_string

                ; In theory, this should have moved the cursor to the top left
                ; corner ("home"), but this doesn't seem to work in practice.
                ; So we send "ESC[H" as well.
                lda.# vt100_home
                jsr print_string
                
z_page          rts

; -------------------------------------------------------------------
; PARSE-NAME ( "name" -- addr u ) 41+ bytes / X cycles
; Find next word in input string, skipping leading spaces. This is a special
; form of PARSE and drops through to that word. See PARSE for more detail. We
; use this word internally for the interpreter because it is a lot easier to use
; http://forth-standard.org/standard/core/PARSE-NAME has a Forth implementation
; Roughly, the word is comparable to  BL WORD COUNT in old terms.
xt_parse-name    
        .!a16
        .!xy16
                ; skip leading spaces, changing >IN, then place SPACE 
                ; character on data stack for PARSE
                phy                     ; save TOS for later use
                ldy.d toin              ; >IN 
        .a8
parse-name_loop
                cpy.d ciblen            ; end of line?
                beq parse-name_empty_line

                lda.diy cib             ; LDA (CIB),Y
                cmp.# AscSP
                bne parse-name_found
                iny
                bra parse-name_loop

parse-name_empty_line
        .a16    
                ; The Gforth documentation does not say what address is returned
                ; if a string with only spaces is returned. Experiments with 
                ; the word  : PNT ( "name" -- ) PARSE-NAME SWAP U. U. TYPE ; 
                ; show that it returns the address of the last space in the
                ; input, which is cib+ciblen. So we do that as well. 
                dex
                dex
                dex
                dex

                ply                     ; restore old TOS as 3OS
                sty.dx 02

                lda.d cib
                clc
                adc.d ciblen
                sta.dx 00               ; Address as NOS

                ldy.# 0000              ; TOS 

                rts                     ; don't have to go through PARSE

parse-name_found
        .!xy16
        .a16
                sty.d toin              ; new >IN

                ply                     ; recover TOS
                dex
                dex
                sty.dx 00

                ldy.# AscSP             ; put space on TOS for PARSE

                ; fall thru to PARSE
                
; -------------------------------------------------------------------
; PARSE ( c "name" -- addr u ) 45 bytes / X+ cycles
; Find word in input string delimited by character given Do not skip leading
; delimiters, this is an important difference to PARSE-NAME. PARSE and
; PARSE-NAME replace WORD in modern systems. See the ANSI documentation at
; http://www.forth200x.org/documents/html3/rationale.html#rat:core:PARSE 
; PARSE-NAME drops through to here
;
;    cib   cib+toin    cib+ciblen
;     v       v             v
;     |#####################|              Length of found string: 
;                                          ciblen - toin
;     +------>|  toin (>IN)
;     +-------------------->|  ciblen
;
; The input string is stored starting at the address in the Current Input Buffer
; (CIB), the length of which is in CIBLEN. While searching for the delimiter,
; TOIN (>IN) points to the where we currently are. Since PARSE does not skip
; leading delimiters, we assume we are on a useful string.
xt_parse         
        .!a16
        .!xy16
                sty.d tmp1      ; save delimiter, char is LSB

                ; save beginning of new word (cib+toin) to NOS. Don't need to
                ; worry about TOS because Y gets clobbered anyway before we
                ; return
                lda.d toin
                sta.d tmp3      ; save >IN for later length calculation
                clc
                adc.d cib

                dex             ; save addr as NOS
                dex
                sta.dx 00

                stz.d tmp2      ; offset for EOL/char found adjustment of >IN

                ; prepare loop using Y as index
                ldy.d toin
        .a8

parse_loop
                cpy.d ciblen    ; check for EOL first
                beq parse_reached_eol

                lda.diy cib     ; LDA (CIB),Y
                cmp.d tmp1      ; found delimiter?
                beq parse_found_delimiter
                iny
                bra parse_loop

parse_found_delimiter
                ; If we haven't reached the end of the line, but found
                ; a delimiter, we want >IN to point to the next character after
                ; the delimiter, not the delimiter itself. This is what the
                ; offset is for
        .a16
                inc.d tmp2      

parse_reached_eol       
                ; calculate length of string found (see ascii drawing)
        .!xy16
        .a16
                tya             
                sec
                sbc.d tmp3      ; original value for >IN / index of first char
                pha             ; save so we can manipulate Y

                ; calculate new >IN
                tya
                clc
                adc.d tmp2      ; offset for EOL vs found delimiter
                sta.d toin

                ply             ; length of string in TOS

z_parse-name
z_parse         rts


; -------------------------------------------------------------------
; +! "PLUSSTORE" ( n addr -- ) 15 bytes / X cycles
; Add NOS to address in TOS
xt_plusstore     
        .!a16
                lda.y 0000
                clc
                adc.dx 00
                sta.y 0000

                ldy.dx 02
                inx
                inx
                inx
                inx

z_plusstore     rts


; -------------------------------------------------------------------
; POSTPONE ( -- ) X bytes / X cycles
; Add the compilation behavior of a word to a new word at compile time. If the
; word that follows it is immediate, include it so that it will be compiled when
; the word being defined is itself used for a new word. Tricky, but very useful.
; Because POSTPONE expects a word (not an xt) in the input stream (not on the
; Data Stack). This means we cannot build words with "jsr xt_postpone, jsr
; <word>" directly. This word uses tmp1
xt_postpone      
                ; get name from string
                jsr xt_parse-name       ; ( addr n ) 

                ; if there is no word in stream, complain and abort
                bne pp_got_word
                lda.# es_noname
                jmp error

pp_got_word
                ; convert to lower
                ; TODO move this to FIND-NAME
                jsr string_to_lowercase

                jsr xt_find-name        ; ( nt | 0 )

                ; if word is not in Dictionary, complain and abort
                bne pp_got_nt
                lda.# es_syntax

pp_got_nt
                ; Keep nt safe for later use
                sty.d tmp1

                ; We need the xt instead of the nt for the actual compiling
                jsr xt_name-int         ; ( xt ) 

                ; See if this is an immediate word. This is easier with nt than
                ; with xt
                lda.di tmp1             ; LDA (TMP1) - get status byte of word
                xba                     ; flags are MSB
                and.# IM                ; mask everything but Immediate bit
                beq pp_not_immediate
                
                ; The word is immediate, so instead of executing it right now,
                ; we compile it. xt is on the stack, so this is simple. The RTS
                ; of COMPILE, takes us back to the original caller
                jmp xt_compilecomma     ; JSR/RTS

pp_not_immediate
                ; This is not an immediate word, so we enact "deffered
                ; compilation" by including ' <NAME> COMPILE, which we do by
                ; compiling the run-time routine of LITERAL, the xt itself, and
                ; a subroutine jump to COMPILE,
                phe.# literal_rt        ; PEA LITERAL_RT
                jsr cmpl_subroutine

                ; The xt is TOS. We can't use COMPILE, here because it might
                ; decided to do something silly like compile it as a native word
                ; and ruin everything
                jsr xt_comma

                ; compile COMPILE, - it's RTS takes us back to original caller
                phe.# xt_compilecomma
                jmp cmpl_subroutine     ; JSR/RTS

z_postpone      ; never reached


; -------------------------------------------------------------------
; R@ "RFETCH" ( -- n ) (R: n -- n )  X bytes / X cycles
; Get (not pull) Top of Return Stack. We follow Gforth in that this word is not
; compiled only, because it can be interesting to know what the top of R is in
; an interactive setting. However, this causes all kinds of problems if we try
; to natively compile the word, so it does not get the NC flag even though it is
; actually short enough to make that reasonable
; TODO consider special case in COMPILE, see there
xt_rfetch        
                ; get return address that is on top of the return stack
                pla

                dex
                dex
                sty.dx 00

                ply     ; get top of return stack and push copy back again
                phy

                pha     ; restore the return address

z_rfetch        rts


; -------------------------------------------------------------------
; R> "FROMR" ( -- n ) (R: n -- )  7 bytes / 23 cycles
; Move Top of Return Stack to Top of Data Stack. Remember we have to move the
; jump address out of the way first.
; TODO consider stripping PHA/PLA if natively compiled (see COMPILE,)
xt_fromr         
                ; Rescue the address of the return jump that is currently top of
                ; the Return Stack. If this word is natively compiled, this is
                ; a waste of nine cycles
                pla

                dex
                dex
                sty.dx 00

                ply             ; the actual work

                pha             ; get return address back

z_fromr         rts


; ------------------------------------------------------------------- 
; REFILL ( -- f ) X bytes / X cycles
; "Attempt to fill the input buffer from the input source, returning a true flag
; if successful. When the input source is the user input device, attempt to
; receive input into the terminal input buffer. If successful, make the result
; the input buffer, set >IN to zero, and return true. Receipt of a line
; containing no characters is considered successful. If there is no input
; available from the current input source, return false. When the input source
; is a string from EVALUATE, return false and perform no other action."
; See https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
; and Conklin & Rather p. 156
xt_refill        
        .!a16
        .!xy16
                ; We handle buffer switches here so that regardless of input
                ; source, we have access to the previous input. This is not in
                ; the ANSI specification in any way.
                lda.d cib
                eor.# 0100      ; flip 07d00 / 07c00
                sta.d cib
                
                lda.d ciblen    ; current length is now previous length
                sta.d piblen
 
                ; Get input source from SOURCE-ID. We don't have blocks in this
                ; version, or else we would have to check BLK first. This is an
                ; optimized version of a subroutine jump to SOURCE-ID
                lda.d insrc
                bne refill_src_not_kbd

                ; SOURCE-ID of zero means we're getting stuff from the keyboard
                ; with ACCEPT. 
                dex                     ; push Data Stack down twice
                dex
                sty.dx 00

                lda.d cib               ; address of current input buffer NOS
                dex
                dex
                sta.dx 00

                ldy.# buffersize 

                jsr xt_accept            ; ( addr n1 -- n2)

                ; ACCEPT returns the number of characters accepted, but we don't
                ; need them. We just overwrite TOS this with the flag
                ldy.# 0ffff

                rts

refill_src_not_kbd
                ; If SOURCE-ID doesn't return a zero, it must be a string in
                ; memory or a file (remember, no blocks in this version)
                inc.a
                bne refill_source_is_not_string

                ; Simply return FALSE flag as per specification
                dex
                dex
                sty.dx 00
                tay

                rts

refill_source_is_not_string
                ; Since we don't have blocks, this must mean that we are trying
                ; to read from a file. However, we don't have files yet, so we 
                ; report an error and jump to ABORT.
                lda.# es_refill2 
                jmp error

z_refill        rts     ; dummy for compiling


; -------------------------------------------------------------------
; ROT ( a b c -- b c a ) X bytes / X cycles
; Rotate the top three entries downwards (third entry becomes first)
; Remember this with the "R" for "revolution": The bottom entry becomes the top.
xt_rot           
        .!a16
        .!xy16
                lda.dx 00       ; save b
                sty.dx 00       ; move c to NOS
                ldy.dx 02       ; move a to TOS
                sta.dx 02       ; save b as 3OS
                
z_rot           rts


; -------------------------------------------------------------------
; S" "SQUOTE" ( "string" -- addr u ) X bytes / X cycles
; Store address and length of string given, returning ( addr u ). ANSI core
; claims this is compile-only, but the file set expands it to be interpreted, so
; it is a state-sensitive word, which are evil. This can also be realized as
; : S" [CHAR] " PARSE POSTPONE SLITERAL ; IMMEDIATE  but it is used so much we
; want it in code
xt_squote        
                ; we use PARSE to find the end of the sting. If the string is
                ; empty, we don't complain, following Gforth's behavior
                dex
                dex
                sty.dx 00

                ldy.# 0022              ; ASCII for " in hex
                jsr xt_parse            ; Returns ( addr u ) of string

                ; What happens now depends on the state. If we are compiling, we
                ; include a subroutine jump to SLITERAL to save the string. If
                ; we are interpreting, we're done
                lda.d state
                beq z_squote            ; if we're interpreting, we're done
                
                ; We're compiling, so we need SLITERAL. We use it's RTS while
                ; we're at it
                jmp xt_sliteral         ; JSR/RTS

z_squote        rts


; -------------------------------------------------------------------
; S>D ( n -- d ) 15 bytes / X cycles
; Convert a single cell number to double cells, conserving the sign
xt_stod          
                dex     ; make room on stack 
                dex
                sty.dx 00

                tya     ; force flag check
                bpl stod_pos
                
                ; negative number, extend sign
                ldy.# 0ffff
                bra z_stod

stod_pos
                ; positive number
                ldy.# 0000      ; fall through

z_stod          rts

; -------------------------------------------------------------------
; SIGN ( n -- ) 13 bytes / X cycles
; If TOS is negative, add a minus sign to the pictured output. Code based on
; https://github.com/philburk/pforth/blob/master/fth/system.fth
; Origin Forth code is  0< IF [CHAR] - HOLD THEN
xt_sign          
        .!a16
                ; See if number is negative
                tya             ; force flag check
                bpl sign_plus

                ; We're negative, overwrite number TOS
                ldy.# 002d      ; ASCII for '-'

                jmp xt_hold     ; JSR/RTS, does not fall through

sign_plus
                ldy.dx 00       ; get rid of number and leave
                inx
                inx
                
z_sign          rts


; -------------------------------------------------------------------
; SLITERAL ( addr u -- ) ( -- addr u ) X bytes / X cycles 
; At compile time, store string, at runtime, return address and length of string
; on the Data Stack. Used for S" among other things. This routine uses tmp1,
; tmp2
xt_sliteral      
        .!a16
                ; We can't assume that ( addr u ) of the current string is in
                ; a stable area, so we first have to move them to safety. Since
                ; CP points to where the interpreter expects to be able to
                ; continue in the code, we have to jump over the string. We use
                ; JMP instead of BRA so we can use longer strings
                lda.dx 00       ; Address of string is NOS
                sta.d tmp1
                sty.d tmp2      ; keep copy of string length

        .a8     
                lda.# 04c       ; opcode for JMP
                sta.di cp       ; STA (CP)
        .a16
                inc.d cp
                
                ; Our jump target is CP + 2 (for the length of the jump
                ; instruction itself ) + the length of the string
                lda.d tmp2      ; string length
                inc.a
                inc.a

                clc
                adc.d cp        ; current address
                sta.di cp       ; store jump target

                ; update CP to move past JMP instruction
                inc.d cp
                inc.d cp

                ; now we can safely copy the code
                dey             ; last offset is one less than length
        .a8
sl_loop
                lda.diy tmp1    ; LDA (TMP1),Y
                sta.diy cp      ; STA (CP),Y
                dey
                bpl sl_loop
        
        .a16
                ; keep old CP as new address of string
                lda.d cp
                sta.d tmp1      ; overwrites original address

                ; update CP
                clc
                adc.d tmp2      ; length of string
                sta.d cp

                ; Compile a subroutine jump to the runtime of SLITERAL that
                ; pushes the new ( addr u ) pair to the Data Stack. When we're
                ; done, the code will look like this:
                ;
                ; xt -->    jmp a
                ;           <string data bytes>
                ;  a -->    jsr sliteral_rt
                ;           <string address>
                ;           <string length>
                ; rts -->
                ;
                ; This means we'll have to adjust the return address for two
                ; cells, not just one
                phe.# sliteral_rt
                jsr cmpl_subroutine

                ; We want to have the addr end up as NOS and the length as TOS,
                ; so we store the address first
                lda.d tmp1      ; new address of string
                pha
                jsr cmpl_word

                lda.d tmp2
                pha
                jsr cmpl_word

                ; all done, clean up and leave
                ldy.dx 02       ; 2DROP
                inx
                inx
                inx
                inx
                
z_sliteral      rts

sliteral_rt
                ; Run time behaviour of SLITERAL: Push ( addr u ) of string to
                ; the Data Stack. We arrive here with the return address as the
                ; top of Return Stack, which points to the address of the string

                ; Make room on stack, which also frees Y for other use
                dex
                dex
                dex
                dex
                sty.dx 02
                
                ; Get the address of the string address off the stack and
                ; increase by one because of the RTS mechanics
                ply
                iny

                lda.y 0000      ; LDA $0000,Y 
                sta.dx 00       ; save string address as NOS
                iny
                iny
                lda.y 0000      ; get length of string, will be TOS ...
                
                iny             ; ... first, though, repair return jump
                phy             

                tay             ; TOS is now length of string

                rts


; -------------------------------------------------------------------
; SOURCE ( -- addr u ) 12 bytes / X cycles
; Return the address and size of current input buffer. Replaces TIB and #TIB in
; ANSI Forth

xt_source       
                dex             ; make room on Data Stack
                dex
                dex
                dex
                sty.dx 02

                lda.d cib       ; address of current input buffer as NOS
                sta.dx 00

                ldy.d ciblen    ; length of current input buffer as TOS
                
z_source        rts

; -------------------------------------------------------------------
; SOURCE-ID ( -- n ) 6 bytes / 13 cycles
; Identify the input source unless it is a block (s. Conklin & Rather p. 156).
; Since we don't have blocks (yet), this will give the input source: 0 is
; keyboard, -1 (0ffff) is character string, and a text file gives the fileid.
xt_source-id     
        .!xy16
                dex
                dex
                sty.dx 00
                ldy.d insrc
                
z_source-id     rts

; -------------------------------------------------------------------
; SPACE ( -- ) X bytes / X cycles
; Print one ASCII space character  
; TODO change to call EMIT
xt_space         
                lda.# AscSP
                jsr put_chr
        .!a16

z_space         rts


; -------------------------------------------------------------------
; SPACES ( u -- ) 12 bytes / X cycles
; Print u spaces. Calls SPACE, because this is probably interactive and humans
; are slow enough we don't have to care about speed.
xt_spaces        
        .!a16
        .!xy16
@
                dey             ; this also handles case u=0
                bmi spaces_done

                jsr xt_space
                bra - 

spaces_done
                ldy.dx 00       ; DROP
                inx
                inx

z_spaces        rts

; -------------------------------------------------------------------
; STAR ( n n -- n ) 16*16 -> 16  X bytes / X cycles
; Multiply two signed 16 bit numbers, returning a 16 bit result. This is nothing
; more than UM* DROP
xt_star          
                jsr xt_umstar
                ldy.dx 00       ; DROP
                inx
                inx

z_star          rts


; -------------------------------------------------------------------
; STATE ( -- addr ) 7 bytes / 12 cycles
; Return the address of a cell containing the compilation-state flag. STATE
; is true when in compilation state, false otherwise. STATE should not be 
; changed directly by the user; see
; http://forth.sourceforge.net/standard/dpans/dpans6.htm#6.1.2250
xt_state         
        .!xy16
                dex
                dex
                sty.dx 00
                ldy.# state
                
z_state         rts


; -------------------------------------------------------------------
; SWAP ( n m -- m n ) 5 bytes / 12 cycles
; Exchange TOS with NOS. We don't check if there are enough elements on the Data
; Stack; underflow errors will go undetected and return garbage.
xt_swap          
        .!a16
        .!xy16
                lda.dx 00
                sty.dx 00
                tay 

z_swap          rts

; -------------------------------------------------------------------
; TRUE ( -- f ) 7 bytes / 12 cycles
; Pushes value $FFFF for Forth true on Data Stack
xt_true          
        .!a16
        .!xy16
                dex
                dex
                sty.dx 00 
                ldy.# 0ffff

z_true          rts

; -------------------------------------------------------------------
; TUCK ( n m -- m n m ) 8 bytes / 19 cycles
; Insert TOS below NOS. We do not check if there are enough elements on the Data
; Stack, underflow will go undetected and return garbage.
xt_tuck          
        .!a16
        .!xy16
                dex
                dex
                lda.dx 2
                sta.dx 0
                sty.dx 2
                
z_tuck          rts

; -------------------------------------------------------------------
; TYPE ( addr u -- ) 23+ bytes / X cycles
; Print character string if u is not 0. We restrict all calls to put_chr and
; get_chr to make porting easier.  We call put_chr here directly instead of
; going through EMIT because EMIT will later have a PAUSE statement for
; multitasking and we probably don't want to PAUSE after every character.
; However, we'll make a final decision about that when multitasking is up and
; running.
xt_type          
        .!a16
        .!xy16
                ; just leave if u is zero (empty string)
                tya             ; force flag check of TOS
                beq type_done

                lda.dx 00       ; get address from NOS 
                sta.d tmp1
                sty.d tmp2      ; number of chars is TOS
                ldy.# 0000
        .a8
type_loop
                lda.diy tmp1    ; LDA (TMP1),Y
                jsr put_chr
                iny
                cpy.d tmp2
                bne type_loop
                
        .a16
type_done
                ; clear stack
                ldy.dx 02
                inx
                inx
                inx
                inx

                ; TODO LATER add PAUSE here for multitasking
                
z_type          rts


; -------------------------------------------------------------------
; UDMOD ( ud u -- u ud ) 32/16 --> 32  X bytes / X cycles
; Devide double-cell number by single-cell number, producing a double-cell
; result and a single-cell remainder. Based on 
; Gforth  : UD/MOD  >R 0 R@ UM/MOD R> SWAP >R UM/MOD R> ;
; pForth  : UD/MOD  >R 0 R@ UM/MOD ROT ROT R> UM/MOD ROT ; 
; This doesn't seem to be used anywhere else but for # (HASH) in coverting
; pictured numerical output, though pForth claims it uses UM/MOD for that
; At some point, we need to get back to UM/MOD because it's optimized
xt_udmod         
                jsr xt_tor
                jsr xt_zero
                jsr xt_rfetch
                jsr xt_ummod
                jsr xt_rot
                jsr xt_rot
                jsr xt_fromr
                jsr xt_ummod
                jmp xt_rot       ; JSR/RTS
z_udmod         


; -------------------------------------------------------------------
; UM* "UMSTAR" ( u u -- ud ) 16*16 -> 32  X bytes / X cycles
; Multiply two unsigned 16 bit numbers, producing a 32 bit result.This is based
; on modified FIG Forth code by Dr. Jefyll, see
; http://forum.6502.org/viewtopic.php?f=9&t=689 for a detailed discussion. We
; use the system scratch pad (SYSPAD) for temp storage (N in the original code)
; FIG Forth is in the public domain. Note old Forth versions such as FIG Forth
; call this "U*"

; This is currently a brute-force loop based on the 8-bit variant in "6502
; Assembly Language Programming" by Leventhal. Once everything is working,
; consider switching to a table-supported version based on
; http://codebase64.org/doku.php?id=base:seriously_fast_multiplication
; http://codebase64.org/doku.php?id=magazines:chacking16#d_graphics_for_the_masseslib3d_and_cool_world
; http://forum.6502.org/viewtopic.php?p=205#p205
; http://forum.6502.org/viewtopic.php?f=9&t=689 We use tmp1, tmp2, tmp3 for
; this, with the assumption that tmp3 immediately follows tmp2
xt_umstar        
        .!a16
                ; SPECIAL CASE 1: multiplication by zero
                tya
                beq umstar_zero
                lda.dx 00
                beq umstar_zero

                ; SPECIAL CASE 2: multiplication by one
                ; This is a different routine than 2* because that instruction
                ; stays inside one cell, whereas UM* produces a Double Cell
                ; answer
                cpy.# 0001      ; non-distructively
                beq umstar_one_tos
                lda.dx 00
                dec.a           ; don't care about distruction
                beq umstar_one_nos

                ; SPECIAL CASE 3: multiplication by two
                cpy.# 0002 
                beq umstar_two_tos

                lda.dx 00
                cmp.# 0002
                beq umstar_two_nos

                ; NO SPECIAL CASE ("The Hard Way") 
                sty.d tmp1      ; TOS number  "40"
                sta.d tmp2      ; NOS number  "41"
                ldy.# &16       ; loop counter

                lda.# 0000
                sta.d tmp3      ; Most Significat Word (MSW) of result
                
umstar_loop
                asl.a           ; useless for first iteration
                rol.d tmp3      ; move carry into MSB, useless first iteration
                asl.d tmp2      ; move bit of NOS number into carry

                ; if there is no carry bit, we don't have to add and can go to
                ; the next bit
                bcc umstar_counter
                
                clc
                adc.d tmp1      ; we have a set bit, so add TOS

                ; if we have a carry, increase the MSW of result
                bcc umstar_counter
                inc.d tmp3

umstar_counter
                dey
                bne umstar_loop

                ; We're all done, clean up and leave
                sta.dx 00       ; store lower cell of number in NOS
                ldy.d tmp3      ; store MSB in TOS as double cell
               
                bra z_umstar    ; don't use RTS so we can natively compile
                
umstar_zero
                ; one or both of the numbers is zero, so we got off light
                ldy.# 0000
                sty.dx 00
                bra z_umstar

umstar_one_tos
                ; TOS is one, life is easy
                dey             ; NOS is LSW, TOS becomes zero
                bra z_umstar
umstar_one_nos  
                ; NOS is one, life is easy
                sty.dx 00
                ldy.# 0000
                bra z_umstar

umstar_two_tos
                ; TOS is two, life is easy
                lda.dx 00
                bra umstar_two_common
umstar_two_nos
                ; NOS is two, life is still easy
                tya 
umstar_two_common
                asl.a           ; multiply by two, top bit in Carry Flag
                sta.dx 00       ; Double Cell LSW is NOS

                lda.# 0000
                rol.a           ; Rotate any Carry Flag into MSW
                tay
                
z_umstar        rts

; -------------------------------------------------------------------
; UM/MOD ( ud u -- u u ) 32/16 -> 16  X bytes / X cycles
; Divide double cell number by single cell number, returning the quotient as TOS
; and any remainder as NOS. All numbers are unsigned. This is the basic division
; operation all others use. Based on Garth Wilson's code at
; http://6502.org/source/integers/ummodfix/ummodfix.htm We use "scratch" for N
; and include a separate detection of division by zero to force an error code
xt_ummod         
        .!a16
        .!xy16
                ; Move the inputs to the scratchpad to avoid having to fool
                ; around with the Data Stack and for speed. Garth's original
                ; code uses the MVN instruction for this, but our TOS is Y which
                ; makes that harder. When we're done, the setup will look likes
                ; this: (S is start of the scratchpad in Direct Page)
                ;
                ;     +-----+-----+-----+-----+-----+-----+-----+-----+
                ;     |  DIVISOR  |        DIVIDEND       | TEMP AREA |
                ;     |           |  hi cell     lo cell  | carry bit |
                ;     |  S    S+1 | S+2   S+3 | S+4   S+5 | S+6   S+7 |
                ;     +-----+-----+-----+-----+-----+-----+-----+-----+
                ;
                ; The divisor is TOS (in Y), high cell of the dividend in NOS,
                ; and low cell in 3OS

                ; Catch division by zero. We could include this in the code as
                ; part of overflow detection (see below), but we want an error
                ; to appear like in Gforth
                tya             ; force flag test
                bne ummod_notzero
                
                lda.# es_divzero
                jmp error

ummod_notzero
                sty.d scratch           ; Y is now free
                lda.dx 00               ; high cell of dividend
                sta.d { scratch + 2 }
                lda.dx 02               ; low cell of dividend
                sta.d { scratch + 4 }

                ; Drop one entry off of the stack and save the new Data Stack
                ; Pointer, freeing X for index duty
                inx
                inx
                stx.d tmpdsp
                
                ; Detect overflow. Subtract divisor from high cell of dividend.
                ; If carry flag remains set, divisor was not large enough to
                ; avoid overflow. This also would detect division by zero, but
                ; we did that already in a separate step
                sec
                lda.d { scratch + 2 }
                sbc.d scratch
                bcs ummod_overflow

                ; If there is no overflow, the carry flag remains clear for
                ; first roll. We loop 16 times, but since we shift the dividend
                ; over at the same time as shifting the answer in, the operation
                ; must start and (!) finish with a shift of the low cell of the
                ; dividend (which ends up holding the quotient), so we start
                ; with 17 times in X. Y is used for temporary storage
                ldx.# &17

ummod_shift
                ; Move low cell of dividend left one bit, also shifting answer
                ; in. The first rotation brings in a zero, which later gets
                ; pushed off the other end in the last rotation
                rol.d { scratch + 4 }

                ; loop control
                dex
                beq ummod_complete

                ; Shift high cell of divident left one bit, also shifting the
                ; next bit in from high bit of low cell
                rol.d { scratch + 2 }
                lda.# 0000
                rol.a
                sta.d { scratch + 6 }   ; store old high bit of dividend

                ; See if divisor will fit into high 17 bits of dividend by
                ; subtracting and then looking at the carry flag. If carry was
                ; cleared, divisor did not fit
                sec
                lda.d { scratch + 2 }
                sbc.d scratch
                tay     ; save difference in Y until we know if we need it

                ; Bit 0 of S+6 serves as the 17th bit. Complete the subtraction
                ; by doing the 17th bit before determining if the divisor fits
                ; into the high 17 bits of the dividend. If so, the carry flag
                ; remains set
                lda.d { scratch + 6 }
                sbc.# 0000
                bcc ummod_shift

                ; Since the divisor fit into high 17 bits, update dividend high
                ; cell to what it would be after subtraction
                sty.d { scratch + 2 }
                bra ummod_shift
                
ummod_overflow
                ; If an overflow condition occurs, put 0ffff
                ; in both the quotient and remainder
                ldx.d tmpdsp            ; restore DSP
                ldy.# 0ffff
                sty.dx 00
                bra z_ummod             ; go to end to enable native coding

ummod_complete
                ldx.d tmpdsp            ; restore DSP
                ldy.d { scratch + 4 }   ; quotient is TOS
                lda.d { scratch + 2 }   ; remainder is NOS
                sta.dx 00       

z_ummod         rts


; -------------------------------------------------------------------
; UNUSED ( -- u ) 11 bytes / X cycles
; Return amount of memory available for the Dictionary. Does not include 
; memory for buffers, stacks etc. Does not exclude the space used by PAD
; TODO rewrite for multitasking
xt_unused        
        .!a16
                lda.# maxram-single
                sec
                sbc.d cp        ; current compile pointer 
                
                dex
                dex
                sty.dx 00

                tay
                
z_unused        rts


; -------------------------------------------------------------------
; VARIABLE ( "name" -- ) X bytes / X cycles
; Define a word that returns the address for a variable. There are various Forth
; definitions for this word, such as  CREATE 1 CELLS ALLOT  or CREATE 0 ,
; We use a variant of the second one so the variable is initialized to zero
xt_variable      
                ; We let CREATE do the heavy lifting
                jsr xt_create

                ; There is no "stz.di cp" so we have to do this the
                ; old way, which is still faster than a subroutine jump to ZERO
                lda.# 0000
                sta.di cp       ; STA (CP)

                inc.d cp        ; direct COMMA
                inc.d cp

z_variable      rts


; -------------------------------------------------------------------
; WORDS&SIZES ( -- ) X bytes / X cycles
; Prints all words in the dictionary with the sizes of their code as returned by
; WORDSIZE. Used to test different optimizations of the compiling routines,
; specific to Liara Forth. Uses tmp3
xt_wordsnsizes   
        .!a16
                lda.# 0ffff
                sta.d tmp3      ; set flag that we want sizes, too

                ; continue with WORDS
                bra words_common

; -------------------------------------------------------------------
; WORDS ( -- ) X bytes / X cycles
; Print list of all Forth words available. This only really makes sense in an
; interactive setting, so we don't have to worry about speed. WORDS&SIZES falls
; through to here. Uses tmp3. Both WORDS and WORDS&SIZES might be better off as
; high-level Forth words, but these routines are left over from early testing
xt_words         
                stz.d tmp3      ; store flag that we don't want to print sizes

words_common
                ; common routine for WORDS and WORDS&SIZES
                jsr xt_cr       ; start on next line, this is a style choice

                lda.d dp        ; nt of first entry in Dictionary (last added)
                pha

                dex             ; create room on TOS
                dex
                sty.dx 00 

words_loop
                tay                      ; ( nt )
                jsr xt_name-string       ; ( nt -- addr u ) 
                jsr xt_type              ; ( addr u -- ) 
                jsr xt_space

                ; If the user wants sizes as well, print them
                lda.d tmp3
                beq words_nosizes

                ; For the moment, just print the size in bytes after the word's
                ; name string. We can decide if we want to get all fancy later
                dex
                dex
                sty.dx 00

                ply             ; get nt back again
                phy             
                jsr xt_wordsize ; ( u ) 
                jsr xt_dot
                jsr xt_space

words_nosizes
                pla             ; get back first entry in Dictionary

                ; The next nt is two bytes below the nt of the current one in
                ; the Dictionary header
                inc.a
                inc.a

                dex
                dex
                sty.dx 00 

                tay
                lda.y 0000              ; LDA $0000,Y
                pha
                bne words_loop          ; zero entry signals end of Dictionary

                ; all done, clean up
                pla                     ; balance MPU stack, value discarded

                ldy.dx 00
                inx
                inx

z_words         
z_wordsnsizes   rts

; -------------------------------------------------------------------
; WORDSIZE ( nt -- u ) X bytes / X cycles
; Given an word's name token (nt), return the size of the word's payload (CFA
; plus PFA) in bytes. Does not count the final RTS. Specific to Liara Forth. 
; Uses tmp2, note WORDS and WORDS&SIZES use tmp3
xt_wordsize      
                ; We get the beginning address of the code from the word's
                ; header entry for the execution token (xt, 4 bytes down) and
                ; the pointer to the end of the code (z_word, six bytes down). 
                iny
                iny
                iny
                iny             ; nt+4, location of xt
                lda.y 0000      ; get xt
                sta.d tmp2

                iny
                iny             ; nt+6, location of z_word
                lda.y 0000
                
                sec             ; (z_word - xt_word) 
                sbc.d tmp2
                tay

z_wordsize      rts


; -------------------------------------------------------------------
; XOR ( n m -- n ) 6 bytes / X cycles
; Logical XOR
xt_xor            
                tya
                eor.dx 00
                tay

                inx
                inx

z_xor            rts


; ===================================================================
; MIDDLE INCLUDES

        .include headers.tasm

; ===================================================================
; CODE FIELD ROUTINES

; ------------------------------------------------------------------- 
; DOCONST 
; Execute a constant: Push the data in the first two byte of the Data Field onto
; the stack
doconst
        .!a16
        .!xy16
                dex             ; make room on Data Stack 
                dex
                sty.dx 00

                ; The value we need is stored two bytes after the JSR return
                ; address, which in turn is what is on top of the Return Stack
                pla             ; get the return address
                sta.d tmp1

                ; start Y as index off with 1 instead of zero because of 65816's
                ; address handling
                ldy.# 0001
                lda.diy tmp1    ; LDA (TMP1),Y
                tay

                rts             ; takes us to original caller
 

; ------------------------------------------------------------------- 
; DODOES
; Used in combination with DOES>'s runtime portion to actually do the work of
; the new word. See DOES> and docs/create-does.txt for details. Uses tmp3
dodoes
                ; Assumes the address of the CFA of the original defining word
                ; (say, CONSTANT) is on the top of the Return Stack. Save it for
                ; a later jump, adding one byte because of the way the 65816
                ; works
                pla
                inc.a
                sta.d tmp3

                ; Next on the Return Stack should be the address of the PFA of
                ; the calling defined word (say, the name of whatever constant we
                ; just defined). Move this to the Data Stack, again adding one.
                dex
                dex
                sty.dx 00

                ply
                iny

                ; This leaves the return address from the original main routine
                ; on top of the Return Stack. We leave that untouched and jump
                ; to the special code of the defining word. It's RTS instruction
                ; will take us back to the main routine
                jmp.i tmp3      ; JMP (TMP3)


; ------------------------------------------------------------------- 
; DOVAR
; Execute a variable: Push the address of the first bytes of the Data Field onto
; the stack. This is called with JSR so we can pick up the address of the
; calling variable off the 65816's Return Stack. The final RTS takes us to the
; original caller of the routine that in turn called DOVAR. This is the default 
; routine installed with CREATE
dovar
        .!a16
        .!xy16
                dex             ; make room on Data Stack 
                dex
                sty.dx 00
 
                ; The address we need is stored in the two bytes after the JSR 
                ; return address, which in turn is what is on top of the Return 
                ; Stack
                ply             ; value is now TOS
                iny             ; add one because of 65816's address handling
                
                rts             ; takes us to original caller


; ===================================================================
; LOW LEVEL HELPER FUNCTIONS


; ------------------------------------------------------------------- 
; INTERPRET
; Core routine for interpreter called by EVALUATE and QUIT. We process one line
; only. Assumes that address of name is in cib and length of whole input 
; string is in ciblen
interpret
interpret_loop 
        .!a16
        .!xy16
                ; Normally we would use PARSE here with the SPACE character as
                ; a parameter (PARSE replaces WORD in modern Forths). However,
                ; Gforth's PARSE-NAME makes more sense as it uses spaces as
                ; delimiters per default and skips any leading spaces, which
                ; PARSE doesn't
                jsr xt_parse-name       ; ( "string" -- addr u ) 

                ; If PARSE-NAME returns 0 (empty line), no characters were left
                ; in the line and we need to go get a new line
                tya                     ; force flag check
                beq interpret_line_done
                
                ; We let the user input words in any case, but use lower case
                ; internally (sorry, Garth).
                jsr string_to_lowercase

                ; Go to FIND-NAME to see if this is a word we know. We have to
                ; make a copy of the address in case it isn't a word we know and
                ; we have to go see if it is a number
                jsr xt_2dup             ; TODO convert this to assembler
                jsr xt_find-name        ; ( addr u -- nt | 0 )

                ; a zero signals that we didn't find a word in the Dictionary
                tya
                bne interpret_got_name_token

                ; We didn't get any nt we know of, so let's see if this is
                ; a number. 
                jsr xt_drop             ; TODO convert this to assembler


                ; If the number conversion doesn't work, NUMBER will do the
                ; complaining for us
                jsr xt_number           ; ( addr u -- u | d ) 
                
                ; That was so much fun we should do it again!
                bra interpret_loop

interpret_got_name_token
                ; We have a known word's nt as TOS. We're going to need its xt
                ; though, which is four byte father down. 
                
                ; Arrive here with ( addr u nt ), so we NIP twice, which is
                ; really fast if Y is TOS 
                inx
                inx
                inx
                inx 

                ; This is a quicker
                ; version of NAME>INT. But first, save a version of nt for
                ; error handling and compilation stuff.
                sty.d tmp1
                iny
                iny
                iny
                iny                    
                lda.y 0000              ; LDA $0000,Y
                tay                     ; xt is TOS

                ; See if we are in interpret or compile mode
                lda.d state
                bne interpret_compile
               
                ; We are interpreting, so EXECUTE the xt that is TOS. First,
                ; though, see if this isn't a compile-only word, which would be
                ; illegal.
                lda.di tmp1
                xba                     ; flags are MSB
                and.# CO                ; mask everything but Compile Only bit
                beq interpret_interpret

                ; TODO see if we can print offending word first
                lda.# es_componly
                jmp error
               
interpret_interpret
                ; We JSR to EXECUTE instead of calling the xt directly because
                ; the RTS of the word we're executing will bring us back here,
                ; skipping EXECUTE completely during RTS. If we were to execute
                ; xt directly, we have to fool around with the Return Stack
                ; instead, which is actually slightly slower
                jsr xt_execute

                ; That's quite enough for this word, let's get the next one
                jmp interpret_loop

interpret_compile
                ; We're compiling. However, we need to see if this is an
                ; IMMEDIATE word, which would mean we execute it right now even
                ; during compilation mode. Fortunately, we saved the nt so life
                ; is easier
                lda.di tmp1
                xba                     ; flags are MSB
                and.# IM                ; Mask all but IM bit
                bne interpret_interpret ; IMMEDIATE word, execute right now

                ; Compile the xt into the Dictionary with COMPILE,
                jsr xt_compilecomma

                jmp interpret_loop

interpret_line_done
                ; drop stuff from PARSE_NAME
                ldy.dx 02
                inx
                inx
                inx
                inx

                rts
                
; ------------------------------------------------------------------- 
; COMPILE WORDS, JUMPS AND SUBROUTINE JUMPS INTO CODE
; These three routines compile instructions such as "jsr xt_words" into a word
; at compile time so they are available at run time. Use by pushing the word or
; address to be compiled on the Return Stack with
;
;       phe.# <WORD>    ; PEA <WORD>
;
; Followed by a jump to which ever versions we need. Words that use this routine
; may not be natively compiled. We use "cmpl" as not to confuse these routines
; with the COMPILE, word. This routine uses tmptos. Always call this with
; a subroutine jump, which means no combining JSR/RTS to JMP.
; TODO see if we need to add a JSR.L variant at some point

        .!a16                   ; paranoid
cmpl_word
                lda.# 0000      ; zero value as a flag, compile word only
                bra cmpl_common
cmpl_subroutine
                lda.# 0020      ; compile "JSR" opcode first
                bra cmpl_common
cmpl_jump
                lda.# 004c      ; compile "JMP", fall through to cmpl_common
cmpl_common
                ; we're going to need the Y register to get anything done 
                sty.d tmptos

                tay             ; force flag check 
                beq cmpl_body   ; came in through cmpl_word, just compile body

                ; A contains an opcode that must be compiled first. This is an
                ; optimized version of C, ("c-comma")
        .a8
                sta.di cp       ; STA (CP)
        .a16
                inc.d cp        ; fall through to cmpl_body
cmpl_body       
                ply             ; the return address we'll need later

                pla             ; next value on stack is the word to compile
                sta.di cp       ; this is a quicker version of , ("comma")
                inc.d cp
                inc.d cp

                phy             ; make sure we can get back home

                ldy.d tmptos    ; restore Data Stack

                rts


; ------------------------------------------------------------------- 
; FATAL ERROR 
; Take address of error string from A, print it and then call abort
error
                jsr print_string
                jmp xt_abort

; ------------------------------------------------------------------- 
; Print a zero terminated string to the console, adding a CR character. Takes
; the address of the string in 16-bit A register, calls put_chr.  A is
; destroyed. We could probably figure out some way to use TYPE instead, but zero
; terminated strings are easier for the 65816 to use.
; TODO add version without final line feed
print_string     
        .!a16
        .!xy16
                ; don't use tmpdsp for X because we don't know if the user has
                ; used it for something already
                phx
                tax             ; x16 contains address of string
@
        .a8
                lda.x 0000      ; LDA $0000,X 
                beq print_string_done
                jsr put_chr
                inx
                bra -

print_string_done
                lda.# AscLF     ; should be CR on some systems
                jsr put_chr
        .a16
                plx
                rts

; ------------------------------------------------------------------- 
; CONVERT BYTE TO ASCII
; Convert byte in A to two ASCII hex digits and print them. Calls 
; nibble_to_ascii. Assumes A is 8 bit. 
byte_to_ascii
                pha
                ; convert high nibble first 
                lsr.a
                lsr.a
                lsr.a
                lsr.a
                jsr nibble_to_ascii

                pla
        
                ; fall thru to nibble_to_ascii


; ------------------------------------------------------------------- 
; CONVERT NIBBLE TO ASCII
; Converts the lower nibble of a number in A and returns the ASCII character
; number, then prints it. Assumes A is 8 bit
nibble_to_ascii
                and.# 000f
                ora.# '0'
                cmp.# 003a       ; '9' + 1
                bcc +
                adc.# 0006
@
                jsr put_chr
        .!a16
                rts

; ------------------------------------------------------------------- 
; Convert a string given by ( addr u ) to lowercase in place. Since we have to
; treat the input buffer as read-only by ANS rules, we have to put the converted
; string somewhere and then return the new address and length
string_to_lowercase
                ; TODO CODE THIS
                rts


; ===================================================================
; HIGH-LEVEL WORDS 

; These are executed during start up. Remember that we have to put a space at
; the end of the line if there is another line with code following it. No zero
; or CR/LF is required
hi-start
        ; High level definitions. Many of these are still defined with BRANCH
        ; and 0BRANCH from Tali Forth, which will be replaced by the ANSI
        ; standard CS-PICK and CS-ROLL words at a later date
        .byte ": ( [char] ) parse 2drop ; immediate " ; ( "parens"
        .byte ": .( [char] ) parse type ; immediate " ; .( "dotparens"
        .byte ": if postpone 0branch here 0 , ; immediate compile-only " ; IF 
        .byte ": then here swap ! ; immediate compile-only " ; THEN
        .byte ": else postpone branch here 0 , here rot ! ; immediate compile-only " ; ELSE
        .byte ": repeat postpone again here swap ! ; immediate compile-only " ; REPEAT
        .byte ": until postpone 0branch , ; immediate compile-only " ; UNTIL
        .byte ": while postpone 0branch here 0 , swap ; immediate compile-only "; WHILE

        ; DEFER and friends. Code taken from ANSI Forth specifications. Many of
        ; these will be moved to assembler code in due course
        .byte ": defer create ['] abort , does> @ execute ; "
        .byte ": defer! >body ! ; "
        .byte ": defer@ >body @ ; "
        ; .byte ": is state @ if postpone ['] postpone defer! else defer! then ; immediate "
        ; .byte ": action-of state @ if postpone ['] postpone defer@ else defer@ then ; immediate "

        ; High level math definitions. The should be moved to actual 65816 code
        ; for speed at some point. Note we use SM/REM instead of FM/MOD for most
        ; stuff. Definitions for SM/REM and FM/MOD taken von Gforth
        ; sources, see
        ; https://groups.google.com/forum/#!topic/comp.lang.forth/_bx4dJFb9R0
        ; .byte ": sm/rem over >r dup >r abs -rot dabs rot um/mod r> r@ xor "
        ; .byte "0< if negate then r> 0< if swap negate swap then ; "
        ; .byte ": fm/mod dup >r dup 0< if negate >r dnegate r> then over " 
        ; .byte "0< if tuck + swap then um/mod r> 0< if swap negate swap then ; "
        ; .byte ": / >r s>d r> sm/rem swap drop ; "
        ; .byte ": /mod >r s>d r> sm/rem ; "
        ; .byte ": */ >r m* r> sm/rem swap drop ; "
        ; .byte ": */mod >r m* r> sm/rem ; "

        ; Output definitions. Since these usually involve the user, and humans
        ; are slow, these can stay high-level for the moment. Based on
        ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
        .byte ": u. 0 <# #s #> type space ; "   ; TODO rewrite in assembler (1 OK) 
        ; .byte ": u.r >r 0 <# #s #> r> over - spaces type ; "
        ; .byte ": .r >r dup abs 0 <# #s rot sign #> r> over - spaces type ; "
        .byte ": ud. <# #s #> type space ; " ; (3 OK)
        ; .byte ": ud.r >r <# #s #> r> over - spaces type ; "
        .byte ": d. tuck dabs <# #s rot sign #> type space ; " ; (2 OK) 
        ; .byte ": d.r >r tuck dabs <# #s rot sign #> r> over - spaces type ; "
;       .byte ": . dup abs 0 <# #s rot sign #> type space ; "

        ; Splash strings. We leave these as high-level words because they are
        ; generated at the end of the boot process and signal that the other
        ; high-level definitions worked (or at least didn't crash)
        .byte ".( Liara Forth for the W65C265SXB )"
        .byte "cr .( Version PRE-ALPHA 28. Feb 2017)"
        .byte "cr .( Scot W. Stevenson <scot.stevenson@gmail.com>)"
        .byte "cr .( Liara Forth comes with absolutely NO WARRANTY)"
        .byte "cr .( Type 'bye' to exit) cr"
hi-end


; ===================================================================
; BOTTOM INCLUDES

        .include strings.tasm

; ===================================================================
; TESTING ROUTINES (UNCOMMENT FOR USE)
              
                ; --- TODO TESTING (PRINT ONE "A") ---
                ; lda.# 61
                ; jsr put_chr
                ; .!a16
                ; brk 00
                ; --- TODO TESTING ---
                 
                ; --- TESTING SHOW WHAT IS TOS --- 
                ; tya
                ; and.# 0ff00
                ; xba 
                ; jsr byte_to_ascii
                ; tya
                ; and.# 00ff
                ; jsr byte_to_ascii
                ; jsr xt_cr
                ; --------------------------------
               
                ; --- TODO TESTING (HALT CPU) ---
                ; brk 00 ; BRK for 265sxb tests (drops back to Mensch Monitor)
                ; stp    ; STP for crude65816 emulator tests
                ; --- TODO TESTING ---
                

; ===================================================================
; END
        .end
