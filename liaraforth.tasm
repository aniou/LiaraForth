; Liara Forth for the W65C265SXB
; Scot W. Stevenson <scot.stevenson@gmail.com>
; First version: 01. Apr 2016
; This version: 04. Jan 2017

; This code is written in Typist's Assembler Notation for the 65c02/65816
; See docs/MANUAL.md for more information

        .mpu 65816
;       .origin 8000    ; start of code to save to Flash memory
        .origin 6000    ; start of code to save to built-in RAM

; ===================================================================
; TOP INCLUDES

        .include definitions.tasm
        .include kernel.tasm


; ===================================================================
; DICTIONARY ROUTINES

; Word code routines are sorted alphabetically, except for the first three
; - COLD, ABORT, and QUIT - and a few others that flow into each other. The
; byte and cycle values are calculated without the RTS instruction.


; -------------------------------------------------------------------
; COLD ( -- ) X bytes / X Cycles
; Reboot the system. TODO determine how to compile this word

a_cold  

                jmp reset_hardware 
start           ; used by hardware reset

        .native
        .axy16
                sei

                ; TODO switch to Single Task mode
                ; TODO set up Direct Page stuff
                ; TODO set up CP
                ; TODO initiate PAD
                ; TODO initiate User variables
                ; TODO initiate high-level words 
                
                ; The name token (nt) of DROP is always the first one in the
                ; clean Dictionary, so we start off the Dictionary Pointer (DP)
                ; there. Adding high-level words will change this before the
                ; user has a chance to call WORDS
                lda.# h_drop
                sta.d dp
                
                ; Prepare input buffers
                lda.# ibuffer1  ; start with first input buffer
                sta.d cib
                stz.d ciblen    ; current input buffer is empty
                stz.d piblen    ; previous input buffer is empty

                ; print boot strings
                lda.# s_title
                jsr print_string
                lda.# s_version
                jsr print_string
                lda.# s_author
                jsr print_string
                lda.# s_disclaimer
                jsr print_string
                lda.# s_typebye
                jsr print_string
                
                ; drop through to QUIT

; -------------------------------------------------------------------
; ABORT ( -- ) 6+ bytes / 6+ cycles
; Reset the parameter (data) stack pointer and continue as QUIT 
; We can jump here via subroutine because we reset the stack pointer
; anyway. Flows into QUIT.

a_abort         ; clear Data Stack
                ldy.# 0000
                ldx.# dsp0

; drops through to QUIT, z_abort is the same as z_quit.

; -------------------------------------------------------------------
; QUIT ( -- ) X bytes / X cycles
; Reset the input, clearning Return Stack. Jumps to QUIT do not have to be
; subroutine jumps as the Return Stack is cleared anyway. Liara Forth follows
; the ANSI Forth recommendation to use REFILL. Note we don't display the "ok"
; system prompt until after the first output.
                
a_quit          ; clear Return Stack
                lda.# stack0
                tcs

                ; switch SOURCE-ID to zero (keyboard input)
                stz.d insrc
                
                ; switch to interpret state (STATE is zero)
                stz.d state
 
                ; TEST TODO REMOVE ONCE WE HAVE FIND-NAME ETC WORKING
                jsr a_words
                jsr a_cr
               
quit_get_line
                ; empty current input buffer. Note the previous input line is
                ; conserved even if we came here from an abort
                stz.d ciblen
               
                ; accept a line from the current input source
                jsr a_refill
                
                tya                     ; force flag test of TOS
                bne quit_refill_successful

                ; If REFILL returned a FALSE flag, something went wrong and we
                ; need to print an error message and reset the machine. We don't
                ; need to save A because we're going to clober it anyway when we
                ; go back to ABORT.
                lda.# es_refill1 
                jmp error 


quit_refill_successful
                ; Assume we have successfully accepted a string of input from
                ; a source, with address of buffer in cib and length of input in
                ; ciblen. We arrive here still with the TRUE flag from REFILL as
                ; TOS (in Y)
                ldy.dx 00       ; drop TOS
                inx
                inx
                
                ; make >IN point to begining of buffer
                stz.d toin
 
                ; TESTING TALI FORTH F_COMPEXE BEGINS HERE
                jsr compile/execute

                ; TODO testing
                ; Display system prompt if all went well
                lda.# s_ok
                jsr print_string

                ; get next line
                jmp quit_get_line

z_cold
z_abort         
z_quit          nop  ; dummy for compilation, TODO test if required

; -------------------------------------------------------------------
; >IN "TO-IN" ( -- addr ) 6 bytes / X cycles
; Return address where pointer to current char in input buffer lives (>IN)

a_to-in         dex
                dex
                sty.dx 00

                ldy.# toin      ; >IN
z_to-in         rts

; -------------------------------------------------------------------
; + "PLUS" ( n m -- n+m ) 7 bytes / X cycles
; Add TOS and NOS

a_plus          tya
                clc
                adc.dx 00
                tay
                inx
                inx 

z_plus          rts

; -------------------------------------------------------------------
; 0 "ZERO" ( -- 0 ) 7 bytes / 12 cycles
; Pushes the number 0000 on the Data Stack

a_zero          dex
                dex
                sty.dx 00 
                ldy.# 0000

z_zero          rts

               
; -------------------------------------------------------------------
; 1 "ONE" ( -- 1 ) 7 bytes / 12 cycles
; Pushes the number 1 on the Data Stack

a_one           dex
                dex
                sty.dx 00
                ldy.# 0001 
   
z_one           rts


; -------------------------------------------------------------------
; 1+ "ONE-PLUS" ( n -- n+1 ) 1 bytes / 2 cycles
; Add 1 to TOS. Because there is no checking if there is actually anything on
; the Data Stack, this routine will fail silently if the stack is empty. 

a_one-plus      iny
z_one-plus      rts

; -------------------------------------------------------------------
; 2 "TWO" ( -- 2 ) 7 bytes / 12 cycles
; Pushes the number 2 on the Data Stack

a_two           dex
                dex
                sty.dx 00
                ldy.# 0002 
   
z_two           rts

; -------------------------------------------------------------------
; 2DUP ( n m -- n m n m ) 10 bytes / 23 cycles
; Duplicated the top two data stack entries

a_2dup          
                dex
                dex
                dex
                dex
                sty.dx 02
                lda.dx 04
                sta.dx 00

z_2dup          rts

; -------------------------------------------------------------------
; ACCEPT ( addr n1 -- n2 ) X bytes / X cycles
; Receive a string of at most n1 characters, placing them at addr. Return the
; actual number of characters as n2. Characters are echoed as they are received

a_accept        
                ; Set up loop
                lda.dx 00       ; max number of chars to accept is NOS
                bne accept_nonzero
                                
                tay             ; if we were told to get zero chars, just quit TODO TEST
                inx
                inx
                rts

accept_nonzero
                sta.d tmp2      ; non-zero number of chars requested, save in tmp2
                sty.d tmp1      ; address of buffer to use in tmp1 
                ldy.# 0000      ; TOS is dropped anyway, so don't save Y
        .a8

accept_loop
                ; TODO rewrite with a KEY so we can revector it
                jsr get_chr   ; blocks with Mensch Monitor

                cmp.# AscLF     ; we quit on both line feed and carriage return
                beq accept_eol

                cmp.# AscCR
                beq accept_eol

                ; cmp.# AscBS     ; CTRL-h, BACKSPACE
                ; beq accept_del

                ; TODO add CTRL-H, CTRL-P, CTRL-O
                ; TODO check if this is a printable character
                
                jsr put_chr   ; echo character. TODO see if this should be EMIT

                ; TODO multitasking: Add PAUSE here (or in EMIT?) 

                sta.diy cib     ; STA (CIB),Y
                iny
                cpy.d tmp2      ; reached character limit? TODO TEST
                bne accept_loop ; fall thru if buffer limit reached

accept_eol
                sty.d ciblen    ; Y contains number of chars accepted already
                inx             
                inx
        .a16

z_accept        rts             ; dummy for compile

; -------------------------------------------------------------------
; BL ( -- u ) 7 bytes / 12 cycles
; Put ASCII char for SPACE on Data Stack

a_bl            dex
                dex
                sty.dx 00
                ldy.# AscSP

z_bl            rts

; -------------------------------------------------------------------
; BYE ( -- ) 2 bytes / 7-8 cycles
; Leave Liara Forth, returning to Mensch Monitor

a_bye           brk 00  ; status byte 00 required for assembler
z_bye           rts     ; dummy for compiling, never reached

; -------------------------------------------------------------------
; COMMA "," ( n -- ) 11 bytes / 29 cycles
; Allot one cell and store TOS in memory. We ignore alignment issues, though
; satisfy the ANSI requirement that an aligned compiler pointer will remain
; aligned
; There is another variant possible: 
;               tya
;               ldy.d cp
;               sta.y 0000
;               iny
;               iny
;               sty.d cp
;               ldy.dx 00
;               inx
;               inx
; This is as fast as the variant below, but three bytes longer

a_comma         tya
                sta.di cp       ; STA (CP)
                inc.d cp
                inc.d cp

                ldy.dx 00
                inx
                inx

z_comma         rts

; -------------------------------------------------------------------
; COUNT ( c-addr -- addr u ) 14 bytes / X cycles
; Convert old-style character string to address-length pair. Note that the
; length of the string c-addr ist stored in character length (8 bit), not cell
; length (16 bit). This is rarely used these days, though COUNT can also be used
; to step through a string character by character. 

a_count         tya
                inc.a           ; String address starts one char later
                dex
                dex
                sta.dx 00       ; NOS
                
                lda.y 0000      ; LDA $0000,Y  first byte is length
                xba             ; move length to LSB
                and.# 00ff      ; get rid of whatever was MSB
                tay             ; TOS
                
z_count         rts


; -------------------------------------------------------------------
; CR ( -- ) X bytes / X cycles
; Cause following output to appear at beginning of next line

a_cr            
        .a8     
                lda.# AscLF     ; test with AscCR for emulators
                jsr put_chr
        .a16

z_cr            rts

; -------------------------------------------------------------------
; DROP ( n -- ) 4 bytes / 9 cycles
; Drop first entry on Data Stack

a_drop          
                ldy.dx 00 
                inx
                inx

z_drop          rts


; -------------------------------------------------------------------
; DUP  ( n -- n n ) 4 bytes / 9 cycles
; Duplicate first entry on Data Stack

a_dup           dex
                dex
                sty.dx 00

z_dup           rts

; -------------------------------------------------------------------
; FALSE ( -- f ) 7 bytes / 12 cycles
; Pushes value $0000 for Forth true on Data Stack. This is the same code as for 
; ZERO, see there. Dictionary entry should have a_zero/z_zero instead of
; a_false/z_false

; -------------------------------------------------------------------
; FIND-NAME ( addr u -- nt | 0 ) 91 bytes / X cycles
; Given a string, find the Name Token (nt) of a word or return zero if the word
; is not in the dictionary. We use this instead of ancient FIND to look up words
; in the Dictionary passed by PARSE-NAME. Note this returns the nt, not the xt
; of a word like FIND. To convert, use NAME>INT. This is a Gforth word. See
; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html 
; FIND calls this word for the hard word

a_find-name     
                ; We abort when we get an empty string, that is, one with
                ; a length of zero TOS. We could test for this, but it will
                ; happen so rarely that the speed penalty is higher if we run
                ; the test for every single call. Looking for an empty string
                ; does force us to check the whole dictionary, though. The test
                ; would be 3 bytes and 4 to 6 cycles longer: 
                ;       tya                     ; force flag check
                ;       beq find-name_failure

                ; set up loop for the first time
                sty.d tmp1      ; length of mystery string in tmp1, Y now free
                ldy.dx 00 
                sty.d tmp2      ; address of mystery string in tmp2, was NOS
                ldy.d dp
                sty.d tmp3      ; nt of first Dictionary word is in tmp3
        .a8

find-name_loop
                ; First quick test: Are strings the same length?
                lda.di tmp3     ; LSB byte in first header word is length
                cmp.d tmp1      ; we test LSB
                bne find-name_next_word

                ; Strings are same length, so second quick test: Is the first
                ; char the same?
                ldy.# 0008      ; name string starts eight bytes from top
                lda.diy tmp3    ; LDA (TMP3),Y
                cmp.di tmp2     ; CMP (TMP2)
                bne find-name_next_word

                ; Save original address of Dictionary entry
                ldy.d tmp3      
                phy

                ; String length is the same, and the first character is the
                ; same. If the word is only one character long, we're done
                lda.d tmp1      ; put a copy of length into TOS just in case
                dec.a           ; faster and shorter than CMP.# 01
                beq find-name_success
                
                ; No such luck: The strings are the same length and the first
                ; char is the same, but the word is more than one char long, so
                ; we suck it up and compare every single character. We go from
                ; back to front, because words like CELLS and CELL+ would take
                ; longer otherwise. We can also shorten the loop by one because
                ; we've already compared the first char. 

                ; Even worse, we have to add 8 bytes to address of Dictionary
                ; string to allow testing with one loop. We need this like
                ; a hole in the head because we just switched A to 8 bit, and
                ; switching back for the sum uses 12 bytes and 18 cycles.
                ; However, staying with an 8-bit A would use 13 bytes and 18
                ; cycles.
                ;       lda.d tmp3              ; LSB
                ;       clc
                ;       adc.# 08
                ;       sta.d tmp3      
                ;       lda.d { tmp3 + 1 }      ; MSB
                ;       adc.# 00                ; we only need the carry
                ;       sta.d { tmp3 + 1 }
                ; Any which way, this is frustrating. 
        .a16
                lda.d tmp3
                clc
                adc.# 0008 
                sta.d tmp3

                lda.d tmp1      ; get length of strings as loop index
                and.# 00ff      ; paranoid
                dec.a           ; first index is length minus 1
                tay             
        .a8

find-name_char_loop
                lda.diy tmp2    ; LDA (TMP2),Y last char of mystery string
                cmp.diy tmp3    ; CMP (TMP3),Y last char of word string
                bne find-name_char_mismatch
                dey             ; start of string (Y=0) was already tested
                bne find-name_char_loop
                
                ; if we reach here, the strings are the same and we have a match
find-name_success
                ply             ; header address (nt) of the found word in TOS
                inx             ; drop the address from NOS (this is NIP) 
                inx
                bra find-name_done

find-name_char_mismatch
                ply             ; original address of dictionary word
                sty.d tmp3      ; put it back in tmp3, fall thru 

find-name_next_word
                ; the address of the next word is two bytes below the current
                ; nt, which we have saved in tmp3. There is no LDY (TMP3), so we
                ; have to do this the hard way
                inc.d tmp3
                inc.d tmp3
        .a16
                lda.di tmp3
                beq find-name_failure   ; zero nt marks end of Dictionary
                sta.d tmp3
        .a8
                bra find-name_loop

find-name_failure
                inx
                inx
                ldy.# 0000      ; return zero, fall thru 
                
find-name_done
                .a16
z_find-name     rts


; -------------------------------------------------------------------
; HERE ( -- u ) 6 bytes / 13 cycles
; Push Compiler Pointer address on the Data Stack

a_here          dex
                dex
                sty.dx 00
                ldy.d cp

z_here          rts

; -------------------------------------------------------------------
; NAME>STRING ( nt -- addr u ) 16 bytes / X cycles
; Given a name token (nt) of a word, return its string. This is a Gforth word
; that works with the Dictionary header entries. It is not checked if nt is
; a valid name token. 
a_name>string   
                dex             ; move NOS down one
                dex

                ; the name string of a word begins 8 bytes down from its nt,
                ; which we have as TOS
                tya
                clc
                adc.# 0008
                sta.dx 00       ; NOS
                
                ; the length of the name string is in the LSB of the first word
                ; of the dictionary entry header (the name token)
                lda.y 0000      ; LDA $0000,Y
                and.# 00ff      ; mask all but length byte
                tay
                
z_name>string   rts


; -------------------------------------------------------------------
; NIP ( n m -- m ) 2 bytes / 4 cycles
; Delete entry that is NOS
;
a_nip           inx
                inx
z_nip           rts

; -------------------------------------------------------------------
; PARSE-NAME ( "name" -- addr u ) 41+ bytes / X cycles
; Find next word in input string, skipping leading spaces. This is a special
; form of PARSE and drops through to that word. See PARSE for more detail. We
; use this word internally for the interpreter because it is a lot easier to use
; http://forth-standard.org/standard/core/PARSE-NAME has a Forth implementation

a_parse-name    
                ; skip leading spaces, changing >IN, then place SPACE 
                ; character on data stack for PARSE
                phy
                ldy.d toin              ; >IN 
        .a8
parse-name_loop
                cpy.d ciblen            ; end of line?
                beq parse-name_empty_line

                lda.diy cib             ; LDA (CIB),Y
                cmp.# AscSP
                bne parse-name_found
                iny
                bra parse-name_loop

parse-name_empty_line
        .a16    
                ; The Gforth documentation does not say what address is returned
                ; if a string with only spaces is returned. Experiments with 
                ; the word  : PNT ( "name" -- ) PARSE-NAME SWAP U. U. TYPE ; 
                ; show that it returns the address of the last space in the
                ; input, which is cib+ciblen. So we do that as well. 
                dex
                dex
                dex
                dex
                ply
                sty.dx 00

                lda.d cib
                clc
                adc.d ciblen
                sta.dx 00               ; NOS address 

                ldy.# 0000              ; TOS 

                rts                     ; don't have to go through PARSE

parse-name_found
        .a16
                sty.d toin              ; new >IN

                dex
                dex
                ply
                sty.d 00

                ldy.# AscSP             ; put space in TOS for PARSE

                ; fall thru to PARSE

; -------------------------------------------------------------------
; PARSE ( c "name" -- addr u ) 45 bytes / X+ cycles
; Find word in input string delimited by character given Do not skip leading
; delimiters, this is an important difference to PARSE-NAME. PARSE and
; PARSE-NAME replace WORD in modern systems. See the ANSI documentation at
; http://www.forth200x.org/documents/html3/rationale.html#rat:core:PARSE 
; PARSE-NAME drops through to here
;
;    cib   cib+toin    cib+ciblen
;     v       v             v
;     |#####################|              Length of found string: 
;                                          ciblen - toin
;     +------>|  toin (>IN)
;     +-------------------->|  ciblen
;
; The input string is stored starting at the address in the Current Input Buffer
; (CIB), the length of which is in CIBLEN. While searching for the delimiter,
; TOIN (>IN) points to the where we currently are. Since PARSE does not skip
; leading delimiters, we assume we are on a useful string.

a_parse         
                sty.d tmp1      ; save delimiter, char is LSB

                ; save beginning of new word (cib+toin) to NOS. Don't need to
                ; worry about TOS because Y gets clobbered anyway
                dex
                dex
                
                lda.d toin
                sta.d tmp3      ; save >IN for later length calculation
                clc
                adc.d cib
                sta.dx 00       

                stz.d tmp2      ; offset for EOL/char found adjustment of >IN

                ; prepare loop
                ldy.d toin
        .a8

parse_loop
                cpy.d ciblen    ; check for EOL first
                beq parse_reached_eol

                lda.diy cib     ; LDA (CIB),Y
                cmp.d tmp1      ; found delimiter?
                beq parse_found_delimiter
                iny
                bra parse_loop

parse_found_delimiter
                ; If we haven't reached the end of the line, but found
                ; a delimiter, we want >IN to point to the next character after
                ; the delimiter, not the delimiter itself. This is what the
                ; offset is for
                inc.d tmp2      

parse_reached_eol       
                ; calculate length of string found (see ascii drawing)
        .a16
                tya             
                sec
                sbc.d tmp3      ; original value for >IN / index of first char
                pha             ; save so we can manipulate Y

                ; calculate new >IN
                tya
                clc
                adc.d tmp2      ; offset for EOL vs found delimiter
                sta.d toin

                ply             ; length of string in TOS

z_parse-name
z_parse         rts

; ------------------------------------------------------------------- 
; REFILL ( -- f ) X bytes / X cycles
; "Attempt to fill the input buffer from the input source, returning a true flag
; if successful. When the input source is the user input device, attempt to
; receive input into the terminal input buffer. If successful, make the result
; the input buffer, set >IN to zero, and return true. Receipt of a line
; containing no characters is considered successful. If there is no input
; available from the current input source, return false. When the input source
; is a string from EVALUATE, return false and perform no other action."
; See https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
; and Conklin & Rather p. 156
a_refill        
                ; We handle buffer switches here so that regardless of input
                ; source, we have access to the previous input. This is not in
                ; the ANSI specification in any way.
                lda.d cib
                eor.# 0100      ; flip 07d00 / 07c00
                sta.d cib
                
                lda.d ciblen
                sta.d piblen

                ; Get input source from SOURCE-ID. We don't have blocks in this
                ; version, or else we would have to check BLK first. This is an
                ; optimized version of a subroutine jump to SOURCE-ID
                lda.d insrc
                bne refill_source_is_not_keyboard

                ; SOURCE-ID of zero means we're getting stuff from the keyboard
                ; with ACCEPT. 
                dex                     ; push Data Stack down twice
                dex
                dex
                dex
                sty.dx 02

                lda.# buffersize        ; 256 chars, ANSI demands at least 80 as NOS
                sta.dx 00

                ldy.d cib               ; address of current input buffer TOS 

                jsr a_accept

                ; Add success flag TRUE
                dex
                dex
                sty.dx 00
                ldy.# 0ffff

                ; TESTING
                rts

refill_source_is_not_keyboard
                ; If SOURCE-ID doesn't return a zero, it must be a string in
                ; memory or a file (remember, no blocks in this version)
                cmp.# 0ffff
                bne refill_source_is_not_string

                ; Simply return FALSE flag as per specification
                dex
                dex
                sty.dx 00
                ldy.# 0000
                rts

refill_source_is_not_string
                ; Since we don't have blocks, this must mean that we are trying
                ; to read from a file. However, we don't have files yet, so we 
                ; report an error and jump to ABORT.
                lda.# es_refill2 
                jmp error

z_refill        rts     ; dummy for compiling

; -------------------------------------------------------------------
; SOURCE ( -- addr u ) 12 bytes / X cycles
; Return the address and size of current input buffer. Replaces TIB and #TIB in
; ANSI Forth

a_source        dex             ; make room on Data Stack
                dex
                dex
                dex
                sty.dx 02

                lda.d cib       ; address of current input buffer as NOS
                sta.dx 00

                ldy.d ciblen    ; length of current input buffer as TOS
                
z_source        rts

; -------------------------------------------------------------------
; SOURCE-ID ( -- n ) 6 bytes / 13 cycles
; Identify the input source unless it is a block (s. Conklin & Rather p. 156).
; Since we don't have blocks (yet), this will give the input source: 0 is
; keyboard, -1 (0ffff) is character string, and a text file gives the fileid.

a_source-id     dex
                dex
                sty.dx 00
                ldy.d insrc
                
z_source-id     rts

; -------------------------------------------------------------------
; SPACE ( -- ) X bytes / X cycles
; Print one ASCII space character

a_space         
        .a8     
                lda.# AscSP
                jsr put_chr
        .a16

z_space         rts

; -------------------------------------------------------------------
; STATE ( -- addr ) 7 bytes / 12 cycles
; Return the address of a cell containing the compilation-state flag. STATE
; is true when in compilation state, false otherwise. STATE should be changed
; directly by the user; see
; http://forth.sourceforge.net/standard/dpans/dpans6.htm#6.1.2250

a_state         dex
                dex
                sty.dx 00
                ldy.# state
                
z_state         rts


; -------------------------------------------------------------------
; SWAP ( n m -- m n ) 5 bytes / 12 cycles
; Exchange TOS with NOS, destroys Y

a_swap          lda.dx 00
                sty.dx 00
                tay 

z_swap          rts

; -------------------------------------------------------------------
; TRUE ( -- f ) 7 bytes / 12 cycles
; Pushes value $FFFF for Forth true on Data Stack

a_true          dex
                dex
                sty.dx 00 
                ldy.# 0ffff

z_true          rts

; -------------------------------------------------------------------
; TUCK ( n m -- m n m ) 8 bytes / 19 cycles
; Insert TOS below NOS

a_tuck          dex
                dex
                lda.dx 2
                sta.dx 0
                sty.dx 2
                
z_tuck          rts

; -------------------------------------------------------------------
; TYPE ( addr u -- ) 23+ bytes / X cycles
; Print character string if u is not 0. We restrict all calls to put_chr and
; get-chr to make porting easier.  We call put_chr here directly instead of
; going through EMIT because EMIT will later have a PAUSE statement for
; multitasking and we probably don't want to PAUSE after every character.
; However, we'll make a final decision about that when multitasking is up and
; running.

a_type          
                ; just leave if u is zero (empty string)
                tya             ; force flag check of TOS
                beq type_done

                lda.dx 00       ; get address from NOS 
                sta.d tmp1
                sty.d tmp2      ; number of chars is TOS
                ldy.# 0000
        .a8
type_loop
                lda.diy tmp1    ; LDA (TMP1),Y
                jsr put_chr
                iny
                cpy.d tmp2
                bne type_loop
                
        .a16
type_done
                ; clear stack
                ldy.dx 02
                inx
                inx
                inx
                inx

                ; TODO LATER add PAUSE here for multitasking
                
z_type          rts

; -------------------------------------------------------------------
; WORDS ( -- ) X bytes / X cycles
; Print list of all Forth words available
;
a_words         
                lda.d dp        ; nt first entry in Dictionary (last added)
                pha

                dex
                dex
                sty.dx 00 

words_loop
                tay

                jsr a_name>string       ; ( nt -- addr u ) 
                jsr a_type              ; ( addr u -- ) 
                jsr a_space

                pla

                ; the next nt is two bytes below the nt of the current one in
                ; the Dictionary header
                ;
                inc.a
                inc.a

                dex
                dex
                sty.dx 00 

                tay
                lda.y 0000              ; LDA $0000,Y
                pha
                bne words_loop

                pla


z_words         rts



; ===================================================================
; MIDDLE INCLUDES

        .include headers.tasm

; ===================================================================
; LOW LEVEL HELPER FUNCTIONS


; ------------------------------------------------------------------- 
; COMPILE OR EXECUTE 
; Core routine for interpreter called by EVALUATE and QUIT. We process one line
; only. Assumes that address of name is in cib and length of whole input 
; string is in ciblen
compile/execute
compex_loop 
                ; Normally we would use PARSE here with the SPACE character as
                ; a parameter (PARSE replaces WORD in modern Forths). However,
                ; Gforth's PARSE-NAME makes more sense as it uses spaces as
                ; delimiters per default and skips any leading spaces, which
                ; PARSE does not do.
                jsr a_parse-name        ; ( addr u ) 

                ; if PARSE-NAME returns 0 (empty line), no characters were left
                ; in the line and we need to go get a new line
                tya             ; force flag check
                beq compex_line_done
                
                ; We let the user input words in any case, but use lower case
                ; internally. Sorry, Garth.
                jsr string_to_uppercase         ; returns ( addr u )

                ; If we got something that is not a zero, we go to FIND-NAME to
                ; get the nt. Returns ( nt | 0 ) 
                jsr a_find-name

                ; a zero signals that we didn't find a word in the Dictionary
                tya             ; force flag check of TOS
                bne compex_got_name_token

                lda.# es_syntax         ; "Unknown word"
                jmp error

compex_got_name_token

                ; TESTING execute word
                ; jsr a_name>int


                ; TESTING Print found string
                ; jsr a_name>string       ; ( nt -- addr u ) 
                ; jsr a_cr
                ; jsr a_type

                ; TODO call NUMBER CONVERSION
                ; TODO INTERPRET or COMPILE 

                ; that's quite enough for this word, let's get the next one
                jmp compex_loop

compex_line_done
                rts
                
; ------------------------------------------------------------------- 
; Fatal error encountered: Take address of error string from A, print it and
; then call abort
error
                jsr print_string
                jmp a_abort


; ------------------------------------------------------------------- 
; Print a zero terminated string to the console, adding a CR character. Takes
; the address of the string in 16-bit A register, calls put_chr.  A is
; destroyed. We could probably figure out some way to use TYPE instead, but zero
; terminated strings are easier for the 65816 to use. 

print_string     
                ; don't use tmpdsp for X because we don't know if the user has
                ; used it for something already
                phx
                tax ; x16 contains address of string
        .a8
@
                lda.x 0000      ; LDA $0000,X 
                beq print_string_done
                jsr put_chr
                inx
                bra -

print_string_done
                lda.# AscLF     ; should be CR on some systems
                jsr put_chr
        .a16
                plx
                rts

; ------------------------------------------------------------------- 
; Convert a string given by ( addr u ) to upper case in place. Since we have to
; treat the input buffer as read-only by ANS rules, we have to put the converted
; string somewhere and then return the new address and length
string_to_uppercase
                ; TODO CODE THIS
                rts

; ===================================================================
; BOTTOM INCLUDES

        .include strings.tasm

; ===================================================================
; TESTING ROUTINES (UNCOMMENT FOR USE)
                
                ; --- TODO TESTING (PRINT ONE "A") ---
                ; lda.# 61
                ; jsr 00:e04b
                ; brk 00
                ; --- TODO TESTING ---
                
                ; --- TODO TESTING (HALT CPU) ---
                ; brk 00 ; BRK for 265sxb tests (drops back to Mensch Monitor)
                ; stp    ; STP for crude65816 emulator tests
                ; --- TODO TESTING ---
                
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


; ===================================================================
; END

        .end
